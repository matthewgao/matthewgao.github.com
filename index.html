<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Matthew Note" />





  <link rel="alternate" href="/atom.xml" title="Matthew Note" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta property="og:type" content="website">
<meta property="og:title" content="Matthew Note">
<meta property="og:url" content="http://gaoshen.site/index.html">
<meta property="og:site_name" content="Matthew Note">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Matthew Note">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://gaoshen.site/"/>





  <title> Matthew Note </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?0d7319169ed36fc7c6c76a85b1353472";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Matthew Note</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://gaoshen.site/分布式锁/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Matthew Gao">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Matthew Note">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Matthew Note" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/分布式锁/" itemprop="url">
                  分布式锁
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/分布式锁/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="分布式锁/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          
              <div class="post-description">
                  这可能是我最跌宕起伏的一年，发生了很多事情，好的坏的，还好在最后一年结束的时候，回头看看所有的结果都是好的，开心
              </div>
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01 简介"></a>0x01 简介</h2><ul>
<li>数据库</li>
<li>KV cache</li>
<li>zookeeper</li>
</ul>
<h2 id="0x02-数据库"><a href="#0x02-数据库" class="headerlink" title="0x02 数据库"></a>0x02 数据库</h2><p>上面这种简单的实现有以下几个问题：</p>
<ol>
<li>这把锁强依赖数据库的可用性，数据库是一个单点，一旦数据库挂掉，会导致业务系统不可用。</li>
<li>这把锁没有失效时间，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁。</li>
<li>这把锁只能是非阻塞的，因为数据的insert操作，一旦插入失败就会直接报错。没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁操作。</li>
<li>这把锁是非重入的，同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了。</li>
</ol>
<p>当然，我们也可以有其他方式解决上面的问题。</p>
<p>数据库是单点？搞两个数据库，数据之前双向同步。一旦挂掉快速切换到备库上。<br>没有失效时间？只要做一个定时任务，每隔一定时间把数据库中的超时数据清理一遍。<br>非阻塞的？搞一个while循环，直到insert成功再返回成功。<br>非重入的？在数据库表中加个字段，记录当前获得锁的机器的主机信息和线程信息，那么下次再获取锁的时候先查询数据库，如果当前机器的主机信息和线程信息在数据库可以查到的话，直接把锁分配给他就可以了。</p>
<p>基于数据库排他锁</p>
<p>除了可以通过增删操作数据表中的记录以外，其实还可以借助数据中自带的锁来实现分布式的锁。</p>
<p>我们还用刚刚创建的那张数据库表。可以通过数据库的排他锁来实现分布式锁。 基于MySql的InnoDB引擎，可以使用以下方法来实现加锁操作：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> boolean <span class="title">lock</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    connection.setAutoCommit(<span class="literal">false</span>)</div><div class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</div><div class="line">        <span class="keyword">try</span>&#123;</div><div class="line">            result = <span class="keyword">select</span> * <span class="keyword">from</span> methodLock <span class="keyword">where</span> method_name=xxx <span class="keyword">for</span> update;</div><div class="line">            <span class="keyword">if</span>(result==<span class="literal">null</span>)&#123;</div><div class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        sleep(<span class="number">1000</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在查询语句后面增加for update，数据库会在查询过程中给数据库表增加排他锁（这里再多提一句，InnoDB引擎在加锁的时候，只有通过索引进行检索的时候才会使用行级锁，否则会使用表级锁。这里我们希望使用行级锁，就要给method_name添加索引，值得注意的是，这个索引一定要创建成唯一索引，否则会出现多个重载方法之间无法同时被访问的问题。重载方法的话建议把参数类型也加上。）。当某条记录被加上排他锁之后，其他线程无法再在该行记录上增加排他锁。</p>
<p>我们可以认为获得排它锁的线程即可获得分布式锁，当获取到锁之后，可以执行方法的业务逻辑，执行完方法之后，再通过以下方法解锁：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</div><div class="line">    connection.commit();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过<code>connection.commit()</code>操作来释放锁。</p>
<p>这种方法可以有效的解决上面提到的无法释放锁和阻塞锁的问题。</p>
<p>阻塞锁？ for update语句会在执行成功后立即返回，在执行失败时一直处于阻塞状态，直到成功。<br>锁定之后服务宕机，无法释放？使用这种方式，服务宕机之后数据库会自己把锁释放掉。<br>但是还是无法直接解决数据库单点和可重入问题。</p>
<p>这里还可能存在另外一个问题，虽然我们对method_name 使用了唯一索引，并且显示使用for update来使用行级锁。但是，MySql会对查询进行优化，即便在条件中使用了索引字段，但是否使用索引来检索数据是由 MySQL 通过判断不同执行计划的代价来决定的，如果 MySQL 认为全表扫效率更高，比如对一些很小的表，它就不会使用索引，这种情况下 InnoDB 将使用表锁，而不是行锁。如果发生这种情况就悲剧了。。。</p>
<p>还有一个问题，就是我们要使用排他锁来进行分布式锁的lock，那么一个排他锁长时间不提交，就会占用数据库连接。一旦类似的连接变得多了，就可能把数据库连接池撑爆</p>
<p>###总结</p>
<p>总结一下使用数据库来实现分布式锁的方式，这两种方式都是依赖数据库的一张表，一种是通过表中的记录的存在情况确定当前是否有锁存在，另外一种是通过数据库的排他锁来实现分布式锁。</p>
<h4 id="数据库实现分布式锁的优点"><a href="#数据库实现分布式锁的优点" class="headerlink" title="数据库实现分布式锁的优点"></a>数据库实现分布式锁的优点</h4><p>直接借助数据库，容易理解。</p>
<h4 id="数据库实现分布式锁的缺点"><a href="#数据库实现分布式锁的缺点" class="headerlink" title="数据库实现分布式锁的缺点"></a>数据库实现分布式锁的缺点</h4><p>会有各种各样的问题，在解决问题的过程中会使整个方案变得越来越复杂。<br>操作数据库需要一定的开销，性能问题需要考虑。<br>使用数据库的行级锁并不一定靠谱，尤其是当我们的锁表并不大的时候。</p>
<h2 id="0x03-KV-cache"><a href="#0x03-KV-cache" class="headerlink" title="0x03 KV cache"></a>0x03 KV cache</h2><p>相比较于基于数据库实现分布式锁的方案来说，基于缓存来实现在性能方面会表现的更好一点。而且很多缓存是可以集群部署的，可以解决单点问题。</p>
<p>目前有很多成熟的缓存产品，包括Redis，memcached以及我们公司内部的Tair。</p>
<p>这里以Tair为例来分析下使用缓存实现分布式锁的方案。关于Redis和memcached在网络上有很多相关的文章，并且也有一些成熟的框架及算法可以直接使用。</p>
<p>基于Tair的实现分布式锁其实和Redis类似，其中主要的实现方式是使用TairManager.put方法来实现。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="built_in">boolean</span> trylock(<span class="keyword">String</span> <span class="built_in">key</span>) &#123;</div><div class="line">    ResultCode code = ldbTairManager.put(NAMESPACE, <span class="built_in">key</span>, <span class="string">"This is a Lock."</span>, <span class="number">2</span>, <span class="number">0</span>);</div><div class="line">    <span class="keyword">if</span> (ResultCode.SUCCESS.equals(code))</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="built_in">boolean</span> unlock(<span class="keyword">String</span> <span class="built_in">key</span>) &#123;</div><div class="line">    ldbTairManager.invalid(NAMESPACE, <span class="built_in">key</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上实现方式同样存在几个问题：</p>
<ol>
<li>这把锁没有失效时间，一旦解锁操作失败，就会导致锁记录一直在tair中，其他线程无法再获得到锁。</li>
<li>这把锁只能是非阻塞的，无论成功还是失败都直接返回。</li>
<li>这把锁是非重入的，一个线程获得锁之后，在释放锁之前，无法再次获得该锁，因为使用到的key在tair中已经存在。无法再执行put操作。</li>
</ol>
<p>当然，同样有方式可以解决。</p>
<p>没有失效时间？tair的put方法支持传入失效时间，到达时间之后数据会自动删除。<br>非阻塞？while重复执行。<br>非可重入？在一个线程获取到锁之后，把当前主机信息和线程信息保存起来，下次再获取之前先检查自己是不是当前锁的拥有者。<br>但是，失效时间我设置多长时间为好？如何设置的失效时间太短，方法没等执行完，锁就自动释放了，那么就会产生并发问题。如果设置的时间太长，其他获取锁的线程就可能要平白的多等一段时间。这个问题使用数据库实现分布式锁同样存在</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>可以使用缓存来代替数据库来实现分布式锁，这个可以提供更好的性能，同时，很多缓存服务都是集群部署的，可以避免单点问题。并且很多缓存服务都提供了可以用来实现分布式锁的方法，比如Tair的put方法，redis的setnx方法等。并且，这些缓存服务也都提供了对数据的过期自动删除的支持，可以直接设置超时时间来控制锁的释放。</p>
<h4 id="使用缓存实现分布式锁的优点"><a href="#使用缓存实现分布式锁的优点" class="headerlink" title="使用缓存实现分布式锁的优点"></a>使用缓存实现分布式锁的优点</h4><p>性能好，实现起来较为方便。</p>
<h4 id="使用缓存实现分布式锁的缺点"><a href="#使用缓存实现分布式锁的缺点" class="headerlink" title="使用缓存实现分布式锁的缺点"></a>使用缓存实现分布式锁的缺点</h4><p>通过超时时间来控制锁的失效时间并不是十分的靠谱。</p>
<h2 id="0x04-zookeeper"><a href="#0x04-zookeeper" class="headerlink" title="0x04 zookeeper"></a>0x04 zookeeper</h2><p>使用ZK实现的分布式锁好像完全符合了本文开头我们对一个分布式锁的所有期望。但是，其实并不是，Zookeeper实现的分布式锁其实存在一个缺点，那就是性能上可能并没有缓存服务那么高。因为每次在创建锁和释放锁的过程中，都要动态创建、销毁瞬时节点来实现锁功能。ZK中创建和删除节点只能通过Leader服务器来执行，然后将数据同不到所有的Follower机器上。</p>
<p>其实，使用Zookeeper也有可能带来并发问题，只是并不常见而已。考虑这样的情况，由于网络抖动，客户端可ZK集群的session连接断了，那么zk以为客户端挂了，就会删除临时节点，这时候其他客户端就可以获取到分布式锁了。就可能产生并发问题。这个问题不常见是因为zk有重试机制，一旦zk集群检测不到客户端的心跳，就会重试，Curator客户端支持多种重试策略。多次重试之后还不行的话才会删除临时节点。（所以，选择一个合适的重试策略也比较重要，要在锁的粒度和并发之间找一个平衡。）</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://gaoshen.site/go/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Matthew Gao">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Matthew Note">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Matthew Note" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/go/" itemprop="url">
                  Golang Note
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/go/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="go/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          
              <div class="post-description">
                  我要所有语言通吃了 gogogo
              </div>
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="TIP"><a href="#TIP" class="headerlink" title="TIP"></a>TIP</h2><ul>
<li>Go command executables are statically linked; the package objects need not be present to run Go programs.</li>
<li>package name 最好和folder名字一致</li>
<li>Executable commands must always use package main.</li>
<li>You write a test by creating a file with a name ending in _test.go that contains functions named TestXXX with signature func (t *testing.T). The test framework runs each such function; if the function calls a failure function such as t.Error or t.Fail, the test is considered to have failed.</li>
<li>在 Go 中，首字母大写的名称是被导出的。在导入包之后，你只能访问包所导出的名字，任何未导出的名字是不能被包外的代码访问的。Foo 和 FOO 都是被导出的名称。名称 foo 是不会被导出的。</li>
<li>函数可以返回任意数量的返回值</li>
<li>没有参数的 return 语句返回各个返回变量的当前值。这种用法被称作“裸”返回。</li>
<li>变量定义可以包含初始值，每个变量对应一个。如果初始化是使用表达式，则可以省略类型；变量从初始值中获得类型。</li>
<li>在函数中， := 简洁赋值语句在明确类型的地方，可以用于替代 var 定义。函数外的每个语句都必须以关键字开始（ var 、 func 、等等）， := 结构不能使用在函数外。</li>
<li>变量在定义时没有明确的初始化时会赋值为 零值 。</li>
<li>与 C 不同的是 Go 的在不同类型之间的项目赋值时需要显式转换。 试着移除例子中 float64 或 int 的转换看看会发生什么。</li>
<li>如果函数参数是指针那么go可以自动转指针即便传入的是值</li>
<li><code>struct{}</code>通常被用作占位符，就是一个空对象</li>
<li><code>break labal</code>和<code>goto</code>不同，前者不会再进入循环/switch</li>
<li>内嵌函数不能以<code>func func_name(){}</code>来声明，只能<code>func_name := func() {}</code></li>
<li>duck type？</li>
<li>shadow value: 实际上就是短声明时候的覆盖问题，你可以使用 vet 命令来发现一些这样的问题。 默认情况下，vet不会执行这样的检查，你需要设置-shadow参数：<code>go tool vet -shadow your_file.go</code></li>
<li>你不能在一个单独的声明中重复声明一个变量，但在多变量声明中这是允许的，其中至少要有一个新的声明变量。</li>
<li>字符串不会为nil</li>
<li><code>x [3]int</code>是数组， <code>x []int</code>是slice，slice是按照传引用？如同python里面的list/dist</li>
<li>以小写字母开头的结构体将不会被（json、xml、gob等）编码，因此当你编码这些未导出的结构体时，你将会得到零值。</li>
<li>在一个nil的channel上发送和接收操作会被永久阻塞。这个行为有详细的文档解释，但它对于新的Go开发者而言是个惊喜。</li>
<li>如果结构体中的各个元素都可以用你可以使用等号来比较的话，那就可以使用相号, ==，来比较结构体变量。</li>
<li>DeepEqual()不会认为空的slice与“nil”的slice相等。这个行为与你使用bytes.Equal()函数的行为不同。bytes.Equal()认为“nil”和空的slice是相等的。</li>
<li>在“range”语句中生成的数据的值是真实集合元素的拷贝。它们不是原有元素的引用。这意味着更新这些值将不会修改原来的数据。同时也意味着使用这些值的地址将不会得到原有数据的指针。</li>
<li>当你重新划分一个slice时，新的slice将引用原有slice的数组。如果你忘了这个行为的话，在你的应用分配大量临时的slice用于创建新的slice来引用原有数据的一小部分时，会导致难以预期的内存使用（因为重新划分的slice占用大小还是原来的大小, 尽管只取了一小部分）。为了避免这个陷阱，你需要从临时的slice中拷贝数据（而不是重新划分slice）。</li>
<li>for语句中的迭代变量在每次迭代时被重新使用。这就意味着你在for循环中创建的闭包（即函数字面量）将会引用同一个变量（而在那些goroutine开始执行时就会得到那个变量的值）。</li>
<li>被defer的函数的参数会在defer声明时求值（而不是在函数实际执行时）</li>
<li>然而并不是所有的变量是可取址的。Map的元素就不是。通过interface引用的变量也不是， 如果你有一个struct值的map，你无法更新单个的struct值，原因就是因为他不可取指，解决方法：第一个有效的方法是使用一个临时变量，另一个有效的方法是使用指针的map。</li>
<li>如果你想知道变量分配的位置，在“go build”或“go run”上传入“-m“ gc标志（即，go run -gcflags -m app.go）</li>
<li>可以显式的唤醒调度器<code>runtime.Gosched()</code></li>
<li><code>iota</code></li>
<li>bytes.Buffer =&gt; StringBuilder 用来拼接字符串</li>
<li>返回值可以返回局部变量的指针，因为go的变量不是组织在栈中的，所以只要有引用他就不会再内存中被回收</li>
<li><code>new(TYPE) === &amp;TYPE{}</code></li>
<li>引用类型： map，slice，channel, func, 方法</li>
<li><code>append(s, t...)</code> 把t切片中所有值拼放到s里</li>
<li><code>switch x.(type)</code> 用于判断类型</li>
<li>Memorize 函数 类似于python里的LRU</li>
<li><code>[]Printable{&amp;b, d}</code> 声明一个接口slice，包含两个接口实现</li>
<li>append一个slice会可能导致cap自动变长，变长之后slice的索引会改变，所以之前生成的subslice不会得到后续的更改</li>
<li><code>type FakeString string</code> FakeString不会自动转string，但是string可以自动转FakeString</li>
<li>type assert 只适用于inferface，其他的还是要用type cast</li>
<li>nil可以赋值给任何指针或引用类型的变量</li>
<li>new返回的是指针，不初始化属性，make是返回值</li>
<li>context 如果不cancel 父context是不会捕获到done的</li>
<li><p><code>go run file.go</code>可以运行go，但是如果目录下有unittest，那么多说情况下还是会出错，所以go通常不适合单独运行，<code>shebang</code>可以让你以近似解析式语言的方式来运行go</p>
</li>
<li><p>同一个目录不能有多个package，目录名字和pacakge可以不一样</p>
</li>
<li>When storage is allocated for a variable, either through a declaration or a call of new, or when a new value is created, either through a composite literal or a call of make, and no explicit initialization is provided, the variable or value is given a default value. Each element of such a variable or value is set to the zero value for its type: false for booleans, 0 for integers, 0.0 for floats, “” for strings, and nil for pointers, functions, interfaces, slices, channels, and maps. This initialization is done recursively, so for instance each element of an array of structs will have its fields zeroed if no value is specified.</li>
<li>json.Marshal 可以用过设置tag <code>json:&quot;my_name, omitempty&quot;</code> 来跳过某个空字段</li>
<li>使用<code>string(120)</code> 是把整型换成他对应的ascii码，应该用<code>strconv.Itoa(120)</code></li>
<li>When you have a struct implementing an interface, a pointer to that struct implements automatically that interface too. That’s why you never have *SomeInterface in the prototype of functions, as this wouldn’t add anything to SomeInterface, and you don’t need such a type in variable declaration </li>
</ul>
<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ul>
<li>slice复制，赋值等</li>
</ul>
<h2 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h2><p>struct的tag使用<code>\``和</code>“` 是一个意思</p>
<p>A field declared with a type but no explicit field name is an anonymous field, also called an embedded field or an embedding of the type in the struct. An embedded type must be specified as a type name T or as a pointer to a non-interface type name *T, and T itself may not be a pointer type. The unqualified type name acts as the field name.</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// A struct with four anonymous fields of type T1, *T2, P.T3 and *P.T4</span></div><div class="line">struct &#123;</div><div class="line">	T1        <span class="comment">// field name is T1</span></div><div class="line">	*T2       <span class="comment">// field name is T2</span></div><div class="line">	P<span class="selector-class">.T3</span>      <span class="comment">// field name is T3</span></div><div class="line">	*P<span class="selector-class">.T4</span>     <span class="comment">// field name is T4</span></div><div class="line">	x, y int  <span class="comment">// field names are x and y</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>A field or method f of an anonymous field in a struct x is called promoted if x.f is a legal selector that denotes that field or method f.</p>
<p>Promoted fields act like ordinary fields of a struct except that they cannot be used as field names in composite literals of the struct.</p>
<p>Given a struct type S and a type named T, promoted methods are included in the method set of the struct as follows:</p>
<ul>
<li>If S contains an anonymous field T, the method sets of S and <em>S both include promoted methods with receiver T. The method set of </em>S also includes promoted methods with receiver *T.</li>
<li>If S contains an anonymous field <em>T, the method sets of S and </em>S both include promoted methods with receiver T or *T.<br>A field declaration may be followed by an optional string literal tag, which becomes an attribute for all the fields in the corresponding field declaration. An empty tag string is equivalent to an absent tag. The tags are made visible through a reflection interface and take part in type identity for structs but are otherwise ignored.</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> &#123;</div><div class="line">	x, y <span class="keyword">float64</span> <span class="string">""</span>  <span class="comment">// an empty tag string is like an absent tag</span></div><div class="line">	name <span class="keyword">string</span>  <span class="string">"any string is permitted as a tag"</span></div><div class="line">	_    [<span class="number">4</span>]<span class="keyword">byte</span> <span class="string">"ceci n'est pas un champ de structure"</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// A struct corresponding to a TimeStamp protocol buffer.</span></div><div class="line"><span class="comment">// The tag strings define the protocol buffer field numbers;</span></div><div class="line"><span class="comment">// they follow the convention outlined by the reflect package.</span></div><div class="line"><span class="keyword">struct</span> &#123;</div><div class="line">	microsec  <span class="keyword">uint64</span> <span class="string">`protobuf:"1"`</span></div><div class="line">	serverIP6 <span class="keyword">uint64</span> <span class="string">`protobuf:"2"`</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Conclude"><a href="#Conclude" class="headerlink" title="Conclude"></a>Conclude</h2><p>interface是描述一个类型的关键因素，根据duck type，一个对象的方法决定了他的类型, 可以用接口的变量来描述结构（struct），这就好像是CPP里多态的基类指针</p>
<h2 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h2><ul>
<li><code>func (t T)Printer() {}</code> 表示T实现了Printer接口</li>
<li><code>func (t *T)Printer() {}</code> 表示T指针实现了Printer接口</li>
<li>The value of an uninitialized variable of interface type is nil.</li>
</ul>
<h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><ul>
<li>如果不带default那么如果channal没有内容他会阻塞，然后等有内容后恢复，之后select整个语句执行完成，如果带default那么如果发现阻塞会直接到default执行default，然后结束select整个过程</li>
<li>select 读取chan的时候，在一个case之间他会一直等待返回，chan才有机会读取下一个，也就是说，这个时候写会导致阻塞，小心死锁</li>
</ul>
<h2 id="constant"><a href="#constant" class="headerlink" title="constant"></a>constant</h2><p>常量的定义与变量类似，只不过使用 const 关键字。<br>常量可以是字符、字符串、布尔或数字类型的值。<br>常量不能使用 := 语法定义。</p>
<h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><p>除非以 fallthrough 语句结束，否则分支会自动终止。<br>没有条件的 switch 同 switch true 一样。<br>这一构造使得可以用更清晰的形式来编写长的 if-then-else 链。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">func</span> <span class="selector-tag">main</span>() &#123;</div><div class="line">    <span class="attribute">t </span>:= time.<span class="built_in">Now</span>()</div><div class="line">    switch &#123;</div><div class="line">    case t.<span class="built_in">Hour</span>() &lt; <span class="number">12</span>:</div><div class="line">        fmt.<span class="built_in">Println</span>(<span class="string">"Good morning!"</span>)</div><div class="line">    case t.<span class="built_in">Hour</span>() &lt; <span class="number">17</span>:</div><div class="line">        fmt.<span class="built_in">Println</span>(<span class="string">"Good afternoon."</span>)</div><div class="line">    default:</div><div class="line">        fmt.<span class="built_in">Println</span>(<span class="string">"Good evening."</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="array和slice"><a href="#array和slice" class="headerlink" title="array和slice"></a>array和slice</h2><p>slice 可以包含任意的类型，包括另一个 slice。<br>slice 可以重新切片，创建一个新的 slice 值指向相同的数组。<br>slice 的零值是 nil 。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">a</span> := make([]int, <span class="number">5</span>)  <span class="comment">// len(a)=5 这会分配一个全是零值的数组并且返回一个 slice 指向这个数组：</span></div><div class="line"><span class="selector-tag">b</span> := make([]int, <span class="number">0</span>, <span class="number">5</span>) <span class="comment">// len(b)=0, cap(b)=5</span></div><div class="line"></div><div class="line"><span class="selector-tag">b</span> = <span class="selector-tag">b</span>[:cap(b)] <span class="comment">// len(b)=5, cap(b)=5</span></div><div class="line"><span class="selector-tag">b</span> = <span class="selector-tag">b</span>[<span class="number">1</span>:]      <span class="comment">// len(b)=4, cap(b)=4</span></div></pre></td></tr></table></figure>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>通过双赋值检测某个键存在：<code>elem, ok = m[key]</code> 如果 key 在 m 中， ok 为 true。否则， ok 为 false，并且 elem 是 map 的元素类型的零值。同样的，当从 map 中读取某个不存在的键时，结果是 map 的元素类型的零值。</p>
<ul>
<li>嵌套的map slice要一次初始化，不然会entry nil </li>
</ul>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">adder</span><span class="params">()</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</div><div class="line">    sum := <span class="number">0</span></div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</div><div class="line">        sum += x</div><div class="line">        <span class="keyword">return</span> sum</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    pos, neg := adder(), adder()</div><div class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</div><div class="line">        fmt.Println(</div><div class="line">            pos(i),</div><div class="line">            neg(<span class="number">-2</span>*i),</div><div class="line">        )</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="interface-1"><a href="#interface-1" class="headerlink" title="interface"></a>interface</h2><p>类型通过实现那些方法来实现接口。 没有显式声明的必要；所以也就没有关键字“implements“。<br>隐式接口解藕了实现接口的包和定义接口的包：互不依赖。<br>因此，也就无需在每一个实现上增加新的接口名称，这样同时也鼓励了明确的接口定义。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import (</div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"math"</span></div><div class="line">)</div><div class="line"></div><div class="line">type Abser interface &#123;</div><div class="line">    Abs() float64</div><div class="line">&#125;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">    <span class="selector-tag">var</span> <span class="selector-tag">a</span> Abser</div><div class="line">    f := MyFloat(-math.Sqrt2)</div><div class="line">    v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</div><div class="line"></div><div class="line">    <span class="selector-tag">a</span> = f  <span class="comment">// a MyFloat 实现了 Abser</span></div><div class="line">    <span class="selector-tag">a</span> = &amp;v <span class="comment">// a *Vertex 实现了 Abser</span></div><div class="line"></div><div class="line">    <span class="comment">// 下面一行，v 是一个 Vertex（而不是 *Vertex）</span></div><div class="line">    <span class="comment">// 所以没有实现 Abser。</span></div><div class="line">    <span class="selector-tag">a</span> = v</div><div class="line"></div><div class="line">    fmt.Println(<span class="selector-tag">a</span>.Abs())</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h2><p>defer 语句会延迟函数的执行直到上层函数返回。<br>延迟调用的参数会立刻生成，但是在上层函数返回前函数都不会被调用。<br>延迟的函数调用被压入一个栈中。当函数返回时， 会按照后进先出的顺序调用被延迟的函数调用。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">"world"</span>)</div><div class="line"></div><div class="line">    fmt.Println(<span class="string">"hello"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><p>在 if 的便捷语句定义的变量同样可以在任何对应的 else 块中使用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"math"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">pow</span><span class="params">(x, n, lim <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</div><div class="line">    <span class="keyword">if</span> v := math.Pow(x, n); v &lt; lim &#123;</div><div class="line">        <span class="keyword">return</span> v</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        fmt.Printf(<span class="string">"%g &gt;= %g\n"</span>, v, lim)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 这里开始就不能使用 v 了</span></div><div class="line">    <span class="keyword">return</span> lim</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    fmt.Println(</div><div class="line">        pow(<span class="number">3</span>, <span class="number">2</span>, <span class="number">10</span>),</div><div class="line">        pow(<span class="number">3</span>, <span class="number">3</span>, <span class="number">20</span>),</div><div class="line">    )</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="native-type"><a href="#native-type" class="headerlink" title="native type"></a>native type</h2><p>bool</p>
<p>string</p>
<p>int  int8  int16  int32  int64<br>uint uint8 uint16 uint32 uint64 uintptr</p>
<p>byte // uint8 的别名</p>
<p>rune // int32 的别名<br>     // 代表一个Unicode码</p>
<p>float32 float64</p>
<p>complex64 complex128<br>这个例子演示了具有不同类型的变量。 同时与导入语句一样，变量的定义“打包”在一个语法块中。<br>int，uint 和 uintptr 类型在32位的系统上一般是32位，而在64位系统上是64位。当你需要使用一个整数类型时，你应该首选 int，仅当有特别的理由才使用定长整数类型或者无符号整数类型。</p>
<h2 id="package"><a href="#package" class="headerlink" title="package"></a>package</h2><p>Go里面有两个保留的函数：init函数（能够应用于所有的package）和main函数（只能应用于package main）。这两个函数在定义时不能有任何的参数和返回值。虽然一个package里面可以写任意多个init函数，但这无论是对于可读性还是以后的可维护性来说，我们都强烈建议用户在一个package中每个文件只写一个init函数。<br>Go程序会自动调用init()和main()，所以你不需要在任何地方调用这两个函数。每个package中的init函数都是可选的，但package main就必须包含一个main函数。<br>程序的初始化和执行都起始于main包。如果main包还导入了其它的包，那么就会在编译时将它们依次导入。有时一个包会被多个包同时导入，那么它只会被导入一次（例如很多包可能都会用到fmt包，但它只会被导入一次，因为没有必要导入多次）。当一个包被导入时，如果该包还导入了其它的包，那么会先将其它包导入进来，然后再对这些包中的包级常量和变量进行初始化，接着执行init函数（如果有的话），依次类推。等所有被导入的包都加载完毕了，就会开始对main包中的包级常量和变量进行初始化，然后执行main包中的init函数（如果存在的话），最后执行main函数。<br>import 下划线（如：import <em> hello/imp）的作用：当导入一个包时，该包下的文件里所有init()函数都会被执行，然而，有些时候我们并不需要把整个包都导入进来，仅仅是是希望它执行init()函数而已。这个时候就可以使用 import </em> 引用该包。即使用【import _ 包路径】只是引用该包，仅仅是为了调用init()函数，所以无法通过包名来调用包中的其他函数。</p>
<h2 id="内嵌"><a href="#内嵌" class="headerlink" title="内嵌"></a>内嵌</h2><p>内嵌是不用显式的指出内嵌类型再去调用内嵌结构的方法，而聚合需要<br>子结构中是不能覆盖内嵌结构中的变量的<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> base <span class="keyword">struct</span> &#123;</div><div class="line">    a <span class="keyword">int</span></div><div class="line">    b <span class="keyword">string</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> derive <span class="keyword">struct</span> &#123;</div><div class="line">    base <span class="comment">//内嵌，这里就可以直接找得到print, 自动转换？还是调用的func (b *base) xfunc()&#123;&#125;</span></div><div class="line">    Base base <span class="comment">//这个就不是内嵌，是聚合所以不算是继承关系, 所以他的对象就不能调用到print, 要显式的指出</span></div><div class="line">    name <span class="keyword">string</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *base)</span> <span class="title">print</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">(ret <span class="keyword">string</span>)</span></span> &#123;</div><div class="line">    ret = <span class="string">"aaa"</span></div><div class="line">    fmt.Printf(<span class="string">"base\n"</span>)</div><div class="line">    <span class="keyword">return</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://medium.com/@Jarema./golang-slice-append-gotcha-e9020ff37374#.mm7wo7moa" target="_blank" rel="external">slice and append gotcha</a><br><a href="https://medium.com/@divan/how-to-avoid-go-gotchas-744bff599b0c#.hjqyn7h1j" target="_blank" rel="external">How to avoid Go gotchas</a></p>
<h2 id="编码规则"><a href="#编码规则" class="headerlink" title="编码规则"></a>编码规则</h2><ul>
<li>全局变量：驼峰式，结合是否可导出确定首字母大小写</li>
<li>参数传递：驼峰式，小写字母开头</li>
<li>局部变量：下划线形式</li>
<li>包名应该为小写单词，不要使用下划线或者混合大小写。</li>
<li>单个函数的接口名以”er”作为后缀，如Reader,Writer，接口的实现则去掉“er”</li>
<li>两个函数的接口名综合两个函数名</li>
<li>三个以上函数的接口名，类似于结构体名</li>
<li>采用全部大写或者全部小写来表示缩写单词</li>
<li>对于少量数据，不要传递指针</li>
<li>对于大量数据的struct可以考虑使用指针</li>
<li>传入参数是map，slice，chan不要传递指针</li>
<li>因为map，slice，chan是引用类型，不需要传递指针的指针</li>
</ul>
<h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><figure class="highlight nix"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">v, <span class="attr">ok</span> = m[key]             // <span class="built_in">map</span> lookup</div><div class="line">v, <span class="attr">ok</span> = x.(T)              // type assertion</div><div class="line">v, <span class="attr">ok</span> = &lt;-ch               // channel receive</div><div class="line"></div><div class="line"><span class="attr">v</span> = m[key]                // <span class="built_in">map</span>查找，失败时返回零值</div><div class="line"><span class="attr">v</span> = x.(T)                 // type断言，失败时panic异常</div><div class="line"><span class="attr">v</span> = &lt;-ch                  // 管道接收，失败时返回零值（阻塞不算是失败）</div><div class="line"></div><div class="line">_, <span class="attr">ok</span> = m[key]            // <span class="built_in">map</span>返回<span class="number">2</span>个值</div><div class="line">_, <span class="attr">ok</span> = mm[<span class="string">""</span>], <span class="literal">false</span>     // <span class="built_in">map</span>返回<span class="number">1</span>个值</div><div class="line"><span class="attr">_</span> = mm[<span class="string">""</span>]                // <span class="built_in">map</span>返回<span class="number">1</span>个值</div></pre></td></tr></table></figure>
<h2 id="var"><a href="#var" class="headerlink" title="var"></a>var</h2><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var (</div><div class="line">	<span class="name">_</span> StdLogger = <span class="symbol">&amp;log</span>.Logger&#123;&#125;</div><div class="line">	_ StdLogger = <span class="symbol">&amp;Entry</span>&#123;&#125;</div><div class="line">	_ StdLogger = <span class="symbol">&amp;Logger</span>&#123;&#125;</div><div class="line">)</div></pre></td></tr></table></figure>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul>
<li>数组是值。将一个数组赋予另一个数组会复制其所有元素。</li>
<li>特别地，若将某个数组传入某个函数，它将接收到该数组的一份副本而非指针。</li>
<li>数组的大小是其类型的一部分。类型 [10]int 和 [20]int 是不同的。</li>
</ul>
<h2 id="append"><a href="#append" class="headerlink" title="append"></a>append</h2><p>但如果我们要像 Append 那样将一个切片追加到另一个切片中呢？ 很简单：在调用的地方使用 …，就像我们在上面调用 Output 那样。以下代码片段的输出与上一个相同。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">x := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</div><div class="line">y := []<span class="keyword">int</span>&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</div><div class="line">x = <span class="built_in">append</span>(x, y...)</div><div class="line">fmt.Println(x)</div></pre></td></tr></table></figure>
<h2 id="runtime-keepAlive"><a href="#runtime-keepAlive" class="headerlink" title="runtime.keepAlive"></a>runtime.keepAlive</h2><p>The purpose of keep alive is to ensure that the garbage collector does not collect a value which is no longer referenced inside a function. The usual cases where this is a problem is if you have obtained the file descriptor to an underlying os.File, or you have passed memory to cgo which was allocated inside the same function.</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">func</span> <span class="selector-tag">g</span>() &#123;</div><div class="line">    <span class="attribute">x </span>:= <span class="built_in">make</span>([]byte, 2^24)</div><div class="line">    y := x[<span class="number">0</span>]</div><div class="line">    if y &gt; <span class="number">0</span> &#123;</div><div class="line">            <span class="built_in">panic</span>(<span class="string">"wat"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Most people would expect that x would be garbage collected before the end of the function because it is no longer referenced. But consider this situation</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">func h() &#123;</div><div class="line">       x, _ := os.Open(<span class="string">"somefile"</span>)</div><div class="line">       fd := x.Fd()</div><div class="line">       // <span class="keyword">use</span> fd <span class="keyword">in</span> <span class="keyword">some</span> kind <span class="keyword">of</span> <span class="keyword">select</span> <span class="keyword">or</span> poll operation inside this <span class="keyword">function</span>.</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>If you’ve follow the logic of what I’ve said up to this point, you would expect x to be dead after the assignment to fd, but we know that *os.File values have a finaliser attached to them, which will be invoked soon after x goes out of scope at the end of the second line.</p>
<p>When that happens, the finalizer will close the file descriptor that fd references. If you’re lucky you’ll get an error about writing to a closed file. If you’re unlucky, another goroutine will open a different file, and receive the same file descriptor number causing file corruption.</p>
<p>The workaround is to use runtime.KeepAlive to keep the reference in x live for the duration of the function.</p>
<p>The moral of the story is finalisers are terrible, and adding one to *os.File was a mistake.</p>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><ul>
<li><code>go build -x</code> 打印出编译相关的信息</li>
</ul>
<h3 id="cgo编译"><a href="#cgo编译" class="headerlink" title="cgo编译"></a>cgo编译</h3><p><a href="http://blog.hashbangbash.com/2014/04/linking-golang-statically/" target="_blank" rel="external">Linking golang statically</a></p>
<h3 id="交叉编译"><a href="#交叉编译" class="headerlink" title="交叉编译"></a>交叉编译</h3><figure class="highlight nix"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">env <span class="attr">GOOS=linux</span> <span class="attr">GOARCH=amd64</span> go build</div></pre></td></tr></table></figure>
<h2 id="接口类型作为参数"><a href="#接口类型作为参数" class="headerlink" title="接口类型作为参数"></a>接口类型作为参数</h2><ul>
<li>接口类型作为参数是否是copy取决于传入参数是指针类型还是struct类型，如果是一个指针类型那么就不会copy</li>
<li>接口传给接口也不会复制</li>
<li>struct赋值给接口会复制</li>
<li>struct指针复制给接口不会复制</li>
</ul>
<p>实际上可以认为所有的类型都是穿值的，只不过有些是指针有些是值<br><a href="https://www.goinggo.net/2016/05/copying-interface-values-in-go.html" target="_blank" rel="external">Copying Interface Values In Go</a></p>
<h2 id="微服务设计"><a href="#微服务设计" class="headerlink" title="微服务设计"></a>微服务设计</h2><ul>
<li>同步是一个比较大的问题，尽量需要同步的由单独的模块来做</li>
<li>Json token在某种情况下可以解决无状态的问题</li>
<li>内部服务消息化更有助于解耦和和去同步</li>
</ul>
<h2 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h2><ul>
<li><code>go test -v -run TESTNAME</code> 可以指定运行单个UT</li>
<li>或者用<code>go test -v xxx_test.go</code> 这里有个问题：<br>But there’s a catch. This works well if</li>
</ul>
<ol>
<li>foo.go is package foo</li>
<li>foo_test.go is package foo_test and imports ‘foo’.</li>
</ol>
<p>If <code>foo_test.go</code> and <code>foo.go</code> are the same package (a common case), then you must name all other files required to build ‘foo_test’. In this example it would be:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ <span class="keyword">go</span> test foo_test.<span class="keyword">go</span> foo.<span class="keyword">go</span></div></pre></td></tr></table></figure>
<h3 id="单独编译成一个binary"><a href="#单独编译成一个binary" class="headerlink" title="单独编译成一个binary"></a>单独编译成一个binary</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">go test -c stream_test<span class="selector-class">.go</span> -o stream<span class="selector-class">.test</span> 单独编译一个UT</div><div class="line">./stream<span class="selector-class">.test</span> -test<span class="selector-class">.v</span> 单独运行</div></pre></td></tr></table></figure>
<h2 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h2><ul>
<li>reflect.ValueOf会成成一个含有复制这个变量的Value对象，所以Set*方法都不能用，因为unaccessable, 如果需要修改，传入的应该是一个指针</li>
<li>interface会复制原始对象</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://gaoshen.site/php/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Matthew Gao">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Matthew Note">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Matthew Note" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/php/" itemprop="url">
                  PHP Note
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/php/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="php/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          
              <div class="post-description">
                  我要所有语言通吃了。。。
              </div>
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="composer"><a href="#composer" class="headerlink" title="composer"></a>composer</h2><p>一个php的包管理的，很近似于npm, 他也是默认不全局的，只是配置某个工程，然后通过json文件自动下载依赖</p>
<h3 id="composer-lock"><a href="#composer-lock" class="headerlink" title="composer.lock"></a>composer.lock</h3><p>是个特殊的文件，记录了创建时各个package的版本，这样下次install的时候保证版本严格一致</p>
<h3 id="autoload"><a href="#autoload" class="headerlink" title="autoload"></a>autoload</h3><p>这个脚本会自动load相应依赖，所以在工程中只要require了这个，那么这些package可以直接拿来使用</p>
<p>require可以返回一个instance，可以后期add package</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$loader = <span class="keyword">require</span> <span class="keyword">__DIR__</span> . <span class="string">'/vendor/autoload.php'</span>;</div><div class="line">$loader-&gt;add(<span class="string">'Acme\\Test\\'</span>, <span class="keyword">__DIR__</span>);</div></pre></td></tr></table></figure>
<p>You can even add your own code to the autoloader by adding an autoload field to composer.json.</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"autoload"</span>: &#123;</div><div class="line">        <span class="attr">"psr-4"</span>: &#123;<span class="attr">"Acme\\"</span>: <span class="string">"src/"</span>&#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="create-a-library"><a href="#create-a-library" class="headerlink" title="create a library"></a>create a library</h3><p>As soon as you have a composer.json in a directory, that directory is a package. When you add a require to a project, you are making a package that depends on other packages. The only difference between your project and libraries is that your project is a package without a name.</p>
<h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h2><ul>
<li>函数内的变量是不受{}scope控制的。类似于js</li>
<li>PHP接受显式的函数参数类型指派，我比较倾向于显示的指出</li>
<li>php namespace是在一个作用域里，如果在另外的引用文件里已经包含了对应的引用文件，本文件中不用再引用一次</li>
<li>mysql connection不用主动释放，执行结束会自动释放</li>
<li>pfsockopen 可以打开一个持久的sock connection </li>
</ul>
<h2 id="set-include-path-amp-get-include-path"><a href="#set-include-path-amp-get-include-path" class="headerlink" title="set_include_path &amp; get_include_path"></a>set_include_path &amp; get_include_path</h2><p><code>set_include_path</code>用于限定include或者require文件的范围，并且使得代码里不必要写一个完整的路径，如果不调用这个方法，那么你可以以相对或者绝对路径的方式访问任何地方，但是如果有了这个只能在他限定的范围内查找</p>
<h2 id="Magic-Func"><a href="#Magic-Func" class="headerlink" title="Magic Func"></a>Magic Func</h2><ul>
<li>__call() 访问类中不存在的对象会调到</li>
<li><strong>invoke() 以类名执行类似python的</strong>call__</li>
<li><strong>get(), </strong>set()</li>
</ul>
<p><a href="http://php.net/manual/zh/language.oop5.magic.php" target="_blank" rel="external">Magic func doc</a></p>
<h2 id="Reflection"><a href="#Reflection" class="headerlink" title="Reflection"></a>Reflection</h2><hr>
<ul>
<li>get_class_name()</li>
<li>get_class_method()</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://segment.com/blog/how-to-make-async-requests-in-php/" target="_blank" rel="external">How to Make Async Requests in PHP</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://gaoshen.site/java/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Matthew Gao">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Matthew Note">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Matthew Note" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/java/" itemprop="url">
                  Java Note
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/java/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="java/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          
              <div class="post-description">
                  我要重新捡起java来
              </div>
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="返回状态值"><a href="#返回状态值" class="headerlink" title="返回状态值"></a>返回状态值</h2><p>默认Java程序不会返回一个状态值，执行成功返回0，如果需要，要调用<code>System。exit</code></p>
<ul>
<li>Java没有无符号整形</li>
<li>char 是一个UTF-16编码的，强烈不要使用char</li>
<li>Java中boolean值是不能和整形比较的</li>
<li>strictfp 强制严格浮点计算</li>
<li><code>&gt;&gt;&gt;</code> 以0填充高位的位移</li>
<li><code>==</code>不能用于比较字符串</li>
</ul>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul>
<li>codepoint</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://gaoshen.site/firstjob/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Matthew Gao">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Matthew Note">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Matthew Note" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/firstjob/" itemprop="url">
                  回顾我的第一份工作
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/firstjob/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="firstjob/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          
              <div class="post-description">
                  是时候做个总结了，也是一个感触吧
              </div>
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="0x00-序"><a href="#0x00-序" class="headerlink" title="0x00 序"></a>0x00 序</h2><p>2012年研究生毕业，我就来到了SonicWALL，当时自己是一个通信专业毕业但是很想去互联网开始第一份职业生涯的人，但是非科班出身的背景和毫无实习经历的我，在寻找第一个工作的时候并没有拿到我特别期待的BAT的Offer，PPS, 中兴，阿朗，SonicWALL成了我最终的候选公司，权衡了多次还是选择去SonicWALL这家看起来不大的做网络安全的外企，后来庆幸决策是对的，四个月后SonicWALL被戴尔收购，变成Dell Security，还加薪了，当时觉得感觉超好,然而悲剧在后面等着你。</p>
<p>想想当时被面试，到后来面试别人，发现确实仅仅通过聊天和写几个程序是完全没办法衡量一个人的潜质的，但是又没有其他更好的办法，所以即便我自认为学习能力很强，但是这种没有任何可以佐证的口号没人相信你，当然也有很怪的公司，比如宝信，竟然在你研究生毕业的时候问你的高考分数，当你报了一个很高的高考分数的时候，对你的态度全变，感觉就不用继续面下去了，就已经过了。</p>
<p>总结这些，我还是想对那些即将毕业的同学们说，别怕得罪你的导师，尽量去外面找实习，公司越大越好，500强，BAT。。。，等你找工作的时候即便笔试面试都不那么出众，也可以相对轻松的拿到Offer。</p>
<h2 id="0x01-工作"><a href="#0x01-工作" class="headerlink" title="0x01 工作"></a>0x01 工作</h2><p>工作内容是开发一个远程接入设备（Secure Mobile Access Appliance 也叫Aventail）, 是一个Debian based server，这份工作的开始对我来说既是机遇，也是一个挑战，机遇在于这是一个全新的组，刚刚成立，开始接手本来在美国的服务器端的开发，组里只有四个人，并且没有专门的PM带，服务器里数十个Daemon，和数十个Kernel module，每个代码量从近万行到10几万行不等，几乎处于个无从下手的情况。</p>
<h3 id="调试和读代码"><a href="#调试和读代码" class="headerlink" title="调试和读代码"></a>调试和读代码</h3><p>当时由于无知，费尽心思想找到一个像VS一样的IDE，让我能够在Linux系统里用单步调试一点点的去跟踪代码，但是尝试了各种，发现都是不可能的，那是一整套基于服务的系统，每一个都是一个本地socket，你想用GDB单步调试都不可能，因为block时间多一点，其他服务就认为你超时，就放弃重连，所以最终我还是回到了最开始我很不屑的打log的方法。对于我这种没有人带的完全home-grown的码农，我自己找到一套适合调试的方法：</p>
<ul>
<li>打log</li>
<li>加abort, 然后分析core dump</li>
<li>抽出局部代码伪造错误case，试图复现</li>
</ul>
<p>我至今都不知道行业有没有更高明的办法，处理这种依赖程度超强的大型系统的debug方法，但是我现在经常用的这三招，基本上帮助了我解决所有简单或者复杂的bug，当然精通gdb是必须的，并且要有些汇编的功底，要了解linkage的过程，和ELF文件格式，这是前提，在处理coredump的时候非常有用。</p>
<p>对于读代码，我也尝试了各种工具，包括被大家广为推崇的VIM，Emacs, sublime, vsc等等等等，Emacs实在是太难的，键盘的映射都要改，所以直接放弃，VIM在配了一堆插件之后确实会变成一个比较好的阅读器和编辑器，我也有自己写了一个自动化的配置脚本<a href="https://github.com/matthewgao/MyVim" target="_blank" rel="external">MyVim</a>, 直到我碰到了source insight。</p>
<p>Source Insight是个非常古老的软件，甚至他连C++11的新关键字和语法都不支持，最新的一版似乎是在2015年3月更新的，也仅仅是打了个patch，但是他确实是一个Windows下看代码的神器，自动哦建立一个相当准确的索引。读代码炒鸡爽。</p>
<p>搞了这么多，我现在也是在vim，vsc, si之间来回的换着用，各有不同的用处，对于一个home-grown的码农来说，够了。</p>
<h3 id="学习和进步"><a href="#学习和进步" class="headerlink" title="学习和进步"></a>学习和进步</h3><p>最开始我也是一个对英语过敏的人，虽然身在外企，还要经常和米国人开会，csdn和google是我最多使用的东西，后来渐渐的我发现，网上大把大把收到的博文和帖子对于问题的处理大多仅仅处于处理问题，对于问题的原因解释不清，我希望我能看到最本质的东西，但是尝试去看一些源代码又太过高难，后来我发现stackoverflow上面的东西老外的回答却是精彩，而且针针见血，所以我开始集中在stackoverflow上尝试解决问题，并且发现他们引用的东西就是相关的官方文档，一点点的我开始忍住恶心看各种我用到的库或者框架的英文文档，很多东西是有中文文档的，但是在我看来中文文档要么老，要么翻译的怪，我甚至要在脑子里把它翻译成英文才能正确理解他的意思，所以我索性只看英文文档，而且我发现这些官方的Get started都写的非常清楚易懂，非常适合我们去读，当然man也是一个好东西，我不会记住每个系统调用或者标准库函数的具体参数，我也记不住，每次用的时候就man一下。</p>
<p>这样下来，久而久之，英语阅读越来越流畅了，也不觉得痛苦了，我觉得除了读书，官方文档是最佳的学习的地方，他会提示你所有可能用错的地方。</p>
<h3 id="代码风格"><a href="#代码风格" class="headerlink" title="代码风格"></a>代码风格</h3><p>刚刚入职的时候，我只是一个能编程的人，但是并不是一个合格的工程师，好的代码风格，编写思路是一个好的工程师必备的能力，这几年来，我发现写代码并不是一个难事，难得是维护代码，一个写的很糟糕的代码是让人很难理解的，你即便读懂了每一行内容，但是却不知道他究竟在干什么，所以代码的可读性非常重要，当然好的文档也非常重要。<br>但是有的时候，代码的可读性和效率是矛盾的，一些时候你可以用一些精妙的方法获得一个非常好的效率提升，但是这会导致你的代码变得难以理解，这个时候衡量可读性和效率就是你要考虑的了，当效率并没成为瓶颈的时候，也就是说你写的优化的代码并没显著提升整个程序的运行速度，那么可读性应该是你第一要保证的，因为代码以后可能不是你来维护，你要让每一个人都能理解你的代码，以至于他不会犯错误。大大降低维护成本，而且现在的计算能力越来越廉价，效率有的时候没必要放的特别重，当然我也不是说你可以乱用内存，粗暴的使用CPU，只是说要学会平和代码的可读性和效率。</p>
<h3 id="开发文档"><a href="#开发文档" class="headerlink" title="开发文档"></a>开发文档</h3><p>我们特别注重开发文档，以至于我们在一个release要花费60-70%的时间在推敲开发文档上面，最终代码实现非常的快，这其实是有好处的，看似你花费了很多时间在一个不必要的事情上，但是这也给你大量的时间反复的设计你的软件，和系统架构，要比草草的实现，然后在重构要好很多，但是这似乎并不匹配中国的开发节奏，所以。。。理想总是骨感的。</p>
<h3 id="让脚本帮你忙"><a href="#让脚本帮你忙" class="headerlink" title="让脚本帮你忙"></a>让脚本帮你忙</h3><p>我们是一个linux based server，所以开发机通常是虚拟机，各种虚拟机，所以在开发不同版本，或者去解不同版本的bug的时候，你就需要一个完整的配置好的虚拟机，这样才能尝试复现问题，那么下载镜像-&gt;创建虚拟机-&gt;安装镜像-&gt;完成初始化配置这一系列动作通常会耗费我大量的时间，而且是重复劳动，我完全可以像一个异步系统一样在这个时候去做其他事情，这个时候各种脚本的价值就凸显了。</p>
<p>Shell和Python是我的最爱，我自己写了脚本可以让整个创建虚拟机的这个过程自动化，我只需运行我的脚本，告诉他我要的版本号，他就会自动的去下载镜像，创建虚拟机，完成初始化配置，而你只要安心的去做其他事情，过个10分钟回来就可以直接用了，所以当你经常在做一个繁琐的事情的时候，考虑让脚本拉你一把。</p>
<h3 id="做一切能做的事"><a href="#做一切能做的事" class="headerlink" title="做一切能做的事"></a>做一切能做的事</h3><p>在这次的几次面试中，几次被问到，你似乎还做运维的工作? 我什么都做，只要我能做，我觉得工作中，任何一个需要解决的问题都是工作的一部分，所以我基本上不会求IT帮我，除非我没权限，搭实验室的时候我自己学着配三层交换机，opengear，甚至自己做网线，能够自己做的事情尽量自己做，都是一种积累，修理变砖的设备也不是我一个开发应该干的，正常流程是返厂，但是我自己还是尝试自己去修，也帮sales省下了大把的销售周期，虽然这跟我没有任何关系，但是我学到了这样一个设备到底是怎么启动并且保证固件不被恶意篡改的，两全其美。</p>
<h2 id="0x02-导师"><a href="#0x02-导师" class="headerlink" title="0x02 导师"></a>0x02 导师</h2><p>我非常庆幸我能在这个公司遇到两个非常好的导师，实际上也不是导师了，只是我和他们共事，<code>Chris D Peterson</code>和<code>William M Perry</code>，他们年龄都很大了，基本上和我父亲同龄，所以他在工作上给我的指导非常有价值。</p>
<p>Chris 1986年从MIT毕业的时候我才刚刚出生，他参与了Linux X windows这个项目的开发，他所开发的模块至今还在所有Linux发行版上使用，他是一个在C++和unix系统开发上相当专注的人，他给了我非常好的编码建议和思路，让我在这四年间受益匪浅，也许是他也很信任我，他把整个系统最核心的由他开发的模块给了我维护，并不断的给我各种建议，我真的感谢他，付出了大量的精力辅导我这么一个小白。</p>
<p>Bill也是很厉害，他是那种真正的全栈，也是整个Aventail的创始人之一，上从CSS下到linux kernel module他全能开发，他给我的职业生涯提供了广度，他的持续学习也深深的影响了我，快50的人了，依然在不断的学习新东西，而且不用很长时间就能上手，我想这是一个程序员的职业精神吧。</p>
<p>我离开Dell最舍不得的就是这两个人，真的对我影响非常之大，我由衷的崇拜和感谢他们，希望我们有机会上海或者西雅图再见面。</p>
<h2 id="0x03-说说戴尔"><a href="#0x03-说说戴尔" class="headerlink" title="0x03 说说戴尔"></a>0x03 说说戴尔</h2><p>再来说说戴尔这个公司吧，总的评价是负面的，首先他不是一个科技公司，他只是个销售公司，他不知道应该怎么做研发，怎么尊重工程师，在戴尔中国，工程师的平均薪资是远远低于销售的，而且最开始被戴尔收购的时候戴尔竟然是用你写了多少行代码，删了多少行代码来评价你的performance的真是无语，戴尔在这种无知的状态下运营了我们4年，导致整个SonicWALL产品线错位，最后又收购了EMC出售了整个软件集团，更恶心的时候竟然不想赔违约的钱，所以对戴尔没什么好评价的，戴尔不是科技公司，以后任何和戴尔相关的公司都慎入，EMC的同志们，小心了。</p>
<h2 id="0x04-在说说中美市场"><a href="#0x04-在说说中美市场" class="headerlink" title="0x04 在说说中美市场"></a>0x04 在说说中美市场</h2><p>我们是一款VPN产品，那么在中国最大的竞争对手是深信服，我有研究过深信服的产品，并没有比我们强大，但是中国市场讲究的是尽可能的满足客户需求，但是米国人并不这么认为，因为他们觉得非标准化的东西是没必要提供的，然而我们恰恰就是卡在这里了，想打开市场，就要改变这个，然而，米国人不愿意，同时米国的节奏也完全的慢半拍，他们的生活确实是和工作平衡的非常好，我也承认那才是生活，但是对于customer issue也慢半拍就会搞得中国客户很不满，毕竟我只负责一部分的开发，我确实尽快解决客户的问题，但是那些由美国和印度开发的模块就完全不受控制了，所以经常说外企在中国水土不服原来越严重不是没有道理的，这根本上是价值观的不同。</p>
<h2 id="0x05-推荐书"><a href="#0x05-推荐书" class="headerlink" title="0x05 推荐书"></a>0x05 推荐书</h2><ul>
<li>代码大全</li>
<li>C++ premier</li>
<li>鸟叔的Linux私房菜</li>
<li>TCP/IP详解</li>
<li>HTTP权威指南</li>
<li>Learning Python</li>
<li>Python Programming</li>
<li>UNIX网络编程</li>
<li>UNIX环境高级编程</li>
<li>JavaScript权威指南</li>
<li>深入理解Linux内核</li>
<li>程序员的自我修养</li>
<li>Effective C++/STL</li>
</ul>
<h2 id="0x06-总结"><a href="#0x06-总结" class="headerlink" title="0x06 总结"></a>0x06 总结</h2><p>四年来我亲手接过了四个模块的核心开发，搭建了上海的Performance lab，解决了无数bug，也帮sales修了许多台被玩坏了了的设备，但是很不幸的是，我走的时候，还没有任何人能够接手我的位置，我觉得我这一走，上海的server开发就要清零了，我是感到无比的可惜，那毕竟是我亲手一点点建立起来的，包括技术，包括信任，那都是我的心血啊，今天去实验室和我亲手搭起来的实验室见了最后一面，我走之前，大概不会再去弄他了，希望其他人可以take care them，我很想把我的所有技能传授给其他留下的人，但是有些东西真的是只能意会不能言传。</p>
<p>总之无奈，离开也并不是我所期待，但是真的是这四年间，戴尔毁了整个公司的节奏，加之这次出售风波，公司的前景在我看来更加不明朗了，Shanghai Site VP很努力的在帮我们争取各种利益，但是结果都是不尽人意，他在这期间苍老了很多，看着很令人心疼，真的非常感谢他，但是无奈，我也没有办法，再见了SonicWALL，再见Aventail，我会在思科或者阿里开始一个全新的职业生涯。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://gaoshen.site/2014-9-12-cpp-note/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Matthew Gao">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Matthew Note">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Matthew Note" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014-9-12-cpp-note/" itemprop="url">
                  C\C++ Notes
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2014-9-12-cpp-note/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014-9-12-cpp-note/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          
              <div class="post-description">
                  记录下C\C++开发过程中不断学到的新东西:C++11, STL, Boost, 多线程
              </div>
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="双重指针"><a href="#双重指针" class="headerlink" title="双重指针"></a>双重指针</h2><pre><code>#include &lt;stdio.h&gt;

int main(){

    char **p=NULL;
    printf(&quot;2 level ptr is:%p\n&quot;,&amp;p);
    printf(&quot;1 level ptr is:%p\n&quot;,p);
    return 0;
}
</code></pre><p>输出结果为</p>
<pre><code>2 level ptr is:0x7fff2b440768
1 level ptr is:(nil)
</code></pre><p>分配地址传给子函数可行，指针传给子函数，让子函数分配地址回传不可行。</p>
<h2 id="数组指针"><a href="#数组指针" class="headerlink" title="数组指针"></a>数组指针</h2><pre><code>char addr[256];
memset(addr+4, 0,20);
</code></pre><p>这样实际上是错误的，虽然说addr本质上是一个指针，但是在<code>addr+4</code>还需要强制转换为<code>void*</code>才可以。</p>
<h2 id="memset-memcpy"><a href="#memset-memcpy" class="headerlink" title="memset/memcpy"></a>memset/memcpy</h2><p>具体内容man</p>
<h2 id="GDB"><a href="#GDB" class="headerlink" title="GDB"></a>GDB</h2><h3 id="检查core-dump"><a href="#检查core-dump" class="headerlink" title="检查core dump"></a>检查core dump</h3><figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">thread</span> apply <span class="literal">all</span> bt <span class="literal">full</span></div></pre></td></tr></table></figure>
<h3 id="检查backtrace的每一层"><a href="#检查backtrace的每一层" class="headerlink" title="检查backtrace的每一层"></a>检查backtrace的每一层</h3><ul>
<li>up 向上一层</li>
<li>down 向下一层</li>
</ul>
<h3 id="显示变量类型"><a href="#显示变量类型" class="headerlink" title="显示变量类型"></a>显示变量类型</h3><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">whatis (<span class="name">param</span>)</div></pre></td></tr></table></figure>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ul>
<li><code>backtrace</code> 显示程序中的当前位置和表示如何到达当前位置的栈跟踪（同义词：<code>where</code>）</li>
<li><code>breakpoint</code> 在程序中设置一个断点</li>
<li><code>cd</code> 改变当前工作目录</li>
<li><code>clear</code> 删除刚才停止处的断点</li>
<li><code>commands</code> 命中断点时，列出将要执行的命令</li>
<li><code>continue</code> 从断点开始继续执行</li>
<li><code>delete</code> 删除一个断点或监测点；也可与其他命令一起使用</li>
<li><code>display</code> 程序停止时显示变量和表达时</li>
<li><code>down</code> 下移栈帧，使得另一个函数成为当前函数</li>
<li><code>frame</code> 选择下一条continue命令的帧</li>
<li><code>info</code> 显示与该程序有关的各种信息</li>
<li><code>jump</code> 在源程序中的另一点开始运行</li>
<li><code>kill</code> 异常终止在gdb 控制下运行的程序</li>
<li><code>list</code> 列出相应于正在执行的程序的原文件内容</li>
<li><code>next</code> 执行下一个源程序行，从而执行其整体中的一个函数</li>
<li><code>print</code> 显示变量或表达式的值</li>
<li><code>pwd</code> 显示当前工作目录</li>
<li><code>pype</code> 显示一个数据结构（如一个结构或C++类）的内容</li>
<li><code>quit</code> 退出gdb</li>
<li><code>reverse-search</code> 在源文件中反向搜索正规表达式</li>
<li><code>run</code> 执行该程序</li>
<li><code>search</code> 在源文件中搜索正规表达式</li>
<li><code>set variable</code> 给变量赋值</li>
<li><code>signal</code> 将一个信号发送到正在运行的进程</li>
<li><code>step</code> 执行下一个源程序行，必要时进入下一个函数</li>
<li><code>undisplay display</code> 命令的反命令，不要显示表达式</li>
<li><code>until</code> 结束当前循环</li>
<li><code>up</code> 上移栈帧，使另一函数成为当前函数</li>
<li><code>watch</code> 在程序中设置一个监测点(即数据断点)</li>
</ul>
<h3 id="其他小诡计"><a href="#其他小诡计" class="headerlink" title="其他小诡计"></a>其他小诡计</h3><p>在程序中加<code>abort()</code> 从而可以在想拿到东西的地方得到core dump</p>
<h2 id="Valgrind-Memory-leak-check-tool"><a href="#Valgrind-Memory-leak-check-tool" class="headerlink" title="Valgrind: Memory leak check tool"></a>Valgrind: Memory leak check tool</h2><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install valgrind</div><div class="line">valgrind (<span class="name">option</span>) (<span class="name">program</span>) (<span class="name">program</span> option)</div></pre></td></tr></table></figure>
<ul>
<li><a href="http://www.ibm.com/developerworks/cn/linux/l-cn-valgrind/" target="_blank" rel="external">参考网站</a></li>
</ul>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#<span class="number">0</span>  <span class="number">0xb7fe1424</span> <span class="keyword">in</span> __kernel_vsyscall ()</div><div class="line">#<span class="number">1</span>  <span class="number">0xb7d5c571</span> <span class="keyword">in</span> raise () <span class="keyword">from</span> /lib/libc.so<span class="number">.6</span></div><div class="line">#<span class="number">2</span>  <span class="number">0xb7d5dd72</span> <span class="keyword">in</span> abort () <span class="keyword">from</span> /lib/libc.so<span class="number">.6</span></div><div class="line">#<span class="number">3</span>  <span class="number">0xb7f9352f</span> <span class="keyword">in</span> __gnu_cxx::__verbose_terminate_handler() () <span class="keyword">from</span> /usr/lib/libstdc++.so<span class="number">.6</span></div><div class="line">#<span class="number">4</span>  <span class="number">0xb7f90eb5</span> <span class="keyword">in</span> __cxxabiv1::__terminate(void (*)()) () <span class="keyword">from</span> /usr/lib/libstdc++.so<span class="number">.6</span></div><div class="line">#<span class="number">5</span>  <span class="number">0xb7f90ef2</span> <span class="keyword">in</span> std::terminate() () <span class="keyword">from</span> /usr/lib/libstdc++.so<span class="number">.6</span></div><div class="line">#<span class="number">6</span>  <span class="number">0xb7f92155</span> <span class="keyword">in</span> __cxa_pure_virtual () <span class="keyword">from</span> /usr/lib/libstdc++.so<span class="number">.6</span></div></pre></td></tr></table></figure>
<p>__cxa_pure_virtual() 调用虚函数，会导致一个runtime error， abort()</p>
<h2 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h2><p>转换失败会返回一个NULL指针，基本只限于对于引用和指针，从父类转子类 或者从子类转父类，所谓的downcast和upcast</p>
<ul>
<li>去<code>const</code>属性用<code>const_cast</code>。</li>
<li>基本类型转换用<code>static_cast</code>。</li>
<li>多态类之间的类型转换用<code>dynamic_cast</code>。</li>
<li>不同类型的指针类型转换用<code>reinterpret_cast</code>。</li>
</ul>
<p>尽量使用C++的新式装换，尽量不用老式转换</p>
<h2 id="switch-case"><a href="#switch-case" class="headerlink" title="switch-case"></a>switch-case</h2><p>case 在没有{}指定范围的时候在其中声明变量会导致编译时候crosses initialization of “XXX” 错误</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> <span class="string">'0'</span>...<span class="string">'9'</span>: <span class="comment">//合法</span></div></pre></td></tr></table></figure>
<h3 id="Parameters"><a href="#Parameters" class="headerlink" title="Parameters"></a>Parameters</h3><h4 id="str"><a href="#str" class="headerlink" title="str"></a>str</h4><p>C string to truncate.<br>Notice that this string is modified by being broken into smaller strings (tokens).<br>Alternativelly, a null pointer may be specified, in which case the function continues scanning where a previous successful call to the function ended.</p>
<h4 id="delimiters"><a href="#delimiters" class="headerlink" title="delimiters"></a>delimiters</h4><p>C string containing the delimiter characters.<br>These can be different from one call to another.</p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* strtok example */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">char</span> str[] =<span class="string">"- This, a sample string."</span>;</div><div class="line">  <span class="keyword">char</span> * pch;</div><div class="line">  <span class="built_in">printf</span> (<span class="string">"Splitting string \"%s\" into tokens:\n"</span>,str);</div><div class="line">  pch = strtok (str,<span class="string">" ,.-"</span>);</div><div class="line">  <span class="keyword">while</span> (pch != <span class="literal">NULL</span>)</div><div class="line">  &#123;</div><div class="line">    <span class="built_in">printf</span> (<span class="string">"%s\n"</span>,pch);</div><div class="line">    pch = strtok (<span class="literal">NULL</span>, <span class="string">" ,.-"</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="C99-支持可变长数组"><a href="#C99-支持可变长数组" class="headerlink" title="C99 支持可变长数组"></a>C99 支持可变长数组</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><ul>
<li>变长数组只能是局部变量，不能是静态变量和全局变量，因为这两者的长度是编译时决定的，而变长数组的长度要到运行时才能确定。变长数组是局部变量，所以是有生命周期的，其生命周期仅在当前域内，即<code>{}</code>内。</li>
<li>变长数组使用的内存是栈内存，所以需要注意数组长度不能太大超过栈内存大小限制。linux 上可以用 ulimit -s 查看栈大小，一般为 8M.</li>
<li>同样适用于支持C99的C++程序</li>
</ul>
<blockquote>
<p>例如：</p>
</blockquote>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"> </div><div class="line"><span class="keyword">int</span> n = <span class="number">10</span>;</div><div class="line"><span class="keyword">int</span> a[n];        <span class="comment">/*非法，VM类型不能具有文件作用域*/</span></div><div class="line"><span class="keyword">int</span> (*p)[n];      <span class="comment">/*非法，VM类型不能具有文件作用域*/</span></div><div class="line"><span class="keyword">struct</span> test</div><div class="line">&#123;</div><div class="line">       <span class="keyword">int</span> k;</div><div class="line">       <span class="keyword">int</span> a[n];     <span class="comment">/*非法，a不是普通标识符*/</span></div><div class="line">       <span class="keyword">int</span> (*p)[n];   <span class="comment">/*非法，p不是普通标识符*/</span></div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="keyword">int</span> main( <span class="keyword">void</span> )</div><div class="line">&#123;</div><div class="line">       <span class="keyword">int</span> m = <span class="number">20</span>;</div><div class="line">       <span class="keyword">struct</span> test1</div><div class="line">       &#123;</div><div class="line">              <span class="keyword">int</span> k;</div><div class="line">              <span class="keyword">int</span> a[n];         <span class="comment">/*非法，a不是普通标识符*/</span></div><div class="line">              <span class="keyword">int</span> (*p)[n];       <span class="comment">/*非法，a不是普通标识符*/</span></div><div class="line">       &#125;;</div><div class="line">       <span class="keyword">extern</span> <span class="keyword">int</span> a[n];       <span class="comment">/*非法，VLA不能具有链接性*/</span></div><div class="line">       <span class="keyword">static</span> <span class="keyword">int</span> b[n];        <span class="comment">/*非法，VLA不能具有静态存储周期*/</span></div><div class="line">       <span class="keyword">int</span> c[n];             <span class="comment">/*合法，自动VLA*/</span></div><div class="line">       <span class="keyword">int</span> d[m][n];          <span class="comment">/*合法，自动VLA*/</span></div><div class="line">       <span class="keyword">static</span> <span class="keyword">int</span> (*p1)[n] = d;  <span class="comment">/*合法，静态VM指针*/</span></div><div class="line">       n = <span class="number">20</span>;</div><div class="line">       <span class="keyword">static</span> <span class="keyword">int</span> (*p2)[n] = d;  <span class="comment">/*未定义行为*/</span></div><div class="line">       <span class="built_in">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="作为形参"><a href="#作为形参" class="headerlink" title="作为形参"></a>作为形参</h3><p>除了可以作为自动对象外，还可以作为函数的形参，下面几个函数原型声明是一样的：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">void func( int a[<span class="string">m</span>][<span class="symbol">n</span>] );</div><div class="line">void func( int a[<span class="string">*</span>][<span class="symbol">n</span>] );</div><div class="line">void func( int a[<span class="string"> </span>][<span class="symbol">n</span>] );</div><div class="line">void func( int a[<span class="string">*</span>][<span class="symbol">*</span>] );</div><div class="line">void func( int a[<span class="string"> </span>][<span class="symbol">*</span>] );</div><div class="line">void func( int (<span class="emphasis">*a)[*</span>] );</div></pre></td></tr></table></figure>
<h3 id="各种限定词"><a href="#各种限定词" class="headerlink" title="各种限定词"></a>各种限定词</h3><p>除了<em>标记外，形参中的数组还可以使用类型限定词const、volatile、restrict和static关键字。由于形参中的VLA被自动调整为等效的指针，因此这些类型限定词实际上限定的是一个指针，例如：`void func( int, int, int a[const][</em>] );<code>等效于</code>void func( int, int, int ( <em>const a )[</em>] );` 它指出a是一个const对象，不能在func内部直接通过a修改其代表的对象。例如：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">void func( int, int, int a[<span class="string">const</span>][<span class="symbol">*</span>] );</div><div class="line">……</div><div class="line">void func( int m, int n, int a[<span class="string">const m</span>][<span class="symbol">n</span>] )</div><div class="line">&#123;</div><div class="line"><span class="code">       int b[m][n];</span></div><div class="line"><span class="code">       a = b;        /*错误，不能通过a修改其代表的对象*/</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>static表示传入的实参的值至少要跟其所修饰的长度表达式的值一样大。例如：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">void func( int, int, int a[<span class="string">const static 20</span>][<span class="symbol">*</span>] );</div><div class="line">……</div><div class="line">int m = 20, n = 10;</div><div class="line">int a[<span class="string">m</span>][<span class="symbol">n</span>];</div><div class="line">int b[<span class="string">n</span>][<span class="symbol">m</span>];</div><div class="line">func( m, n, a );</div><div class="line">func( m, n, b );     /<span class="emphasis">*错误，b的第一维长度小于static 20*</span>/</div></pre></td></tr></table></figure>
<p>类型限定词和static关键字只能用于具有数组类型的函数形参的第一维中。这里的用词是数组类型，意味着它们不仅能用于VLA，也能用于一般数组形参。</p>
<h2 id="const-函数"><a href="#const-函数" class="headerlink" title="const 函数"></a>const 函数</h2><ul>
<li>常成员函数不能更新对象的数据成员 </li>
<li>不能调用该类中没有const修饰的成员函数</li>
<li>当类的实例为一个const object的时候只能调用const函数</li>
</ul>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="built_in">Object</span>* obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">obj.func(); <span class="comment">//这里func必须为const函数 不然就不对</span></div></pre></td></tr></table></figure>
<h2 id="友元-friend"><a href="#友元-friend" class="headerlink" title="友元 friend"></a>友元 friend</h2><ul>
<li>友元函数可以访问其类中的成员，并且不受private protect的限制</li>
<li>类也可以是友元，友元类可以访问其所在类的成员</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> A&#123;</div><div class="line">  <span class="keyword">public</span>：</div><div class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="title">func</span><span class="params">()</span></span>; <span class="comment">//声明友元</span></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">int</span> a;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="title">func</span><span class="params">()</span></span>&#123;</div><div class="line">	some code <span class="comment">//友元的定义</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="STL和boost"><a href="#STL和boost" class="headerlink" title="STL和boost"></a>STL和boost</h2><ul>
<li>make_pair(obj) 和 push_back(obj) 都会调用obj的拷贝构造函数，构造一个新函数，所以使用时要注意obj是否有一个合适的拷贝构造函数 </li>
<li>Copy in, copy out.</li>
</ul>
<h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><ul>
<li>注意循环引用（cycle）</li>
<li>可以正确的在STL container中使用</li>
</ul>
<p>这里bad()的使用方法会可能导致临时shared_ptr指向对象不会被正确释放（在exception case下）<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">ok</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p( <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">2</span>) );</div><div class="line">    f( p, g() );</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">bad</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    f( <span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt;( <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">2</span>) ), g() );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight cos"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">shared_ptr&lt;<span class="keyword">Job</span>&gt; <span class="keyword">j</span> = make_shared&lt;<span class="keyword">Job</span>&gt;()<span class="comment">; //make_shared比用new更加高效，</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//这个函数会在传入时候复制一次shared_ptr，导致引用计数+1，之后return的时候又复制一次，导致引用计数又+1，但是这都会在函数执行后</span></div><div class="line"><span class="comment">//被正确释放掉</span></div><div class="line">shared_ptr&lt;<span class="keyword">Job</span>&gt; func(shared_ptr&lt;<span class="keyword">Job</span>&gt; <span class="keyword">job</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">job</span><span class="comment">;</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//全程不会增加引用计数，但是要小心，如果这个shared_ptr的会被其他线程赋值，那么这可能会有问题</span></div><div class="line">shared_ptr&lt;<span class="keyword">Job</span>&gt;&amp; func(shared_ptr&lt;<span class="keyword">Job</span>&gt;&amp; <span class="keyword">job</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">job</span><span class="comment">;</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//这个时候job会被赋值，job所指的老的对象会被释放掉，job会继续跟踪这个新建对象。</span></div><div class="line">shared_ptr&lt;<span class="keyword">Job</span>&gt;&amp; func(shared_ptr&lt;<span class="keyword">Job</span>&gt;&amp; <span class="keyword">job</span>)&#123;</div><div class="line">    <span class="keyword">job</span> = make_shared&lt;<span class="keyword">Job</span>&gt;()<span class="comment">;</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">job</span><span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>如果以引用传递shared_ptr参数，那么他不能操纵他自己，不然会编译报错</li>
</ul>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Association::addToManager(shared_ptr&lt;Association&gt;&amp; <span class="built_in">assoc</span>);</div><div class="line"><span class="built_in">assoc</span>-&gt;addToManager(<span class="built_in">assoc</span>);// 这里addToManager无法接受一个<span class="built_in">assoc</span>的引用</div></pre></td></tr></table></figure>
<ul>
<li><p>shared_ptr不能用static_cast等直接做转换，要用它提供的“</p>
<ul>
<li>static_pointer_cast<t></t></li>
<li>const_pointer_cast<t></t></li>
<li>dynamic_pointer_cast<t></t></li>
</ul>
</li>
<li><p><a href="http://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/" target="_blank" rel="external">91 Solution: Smart Pointer Parameters</a></p>
</li>
</ul>
<h3 id="string是否是有引用实现的"><a href="#string是否是有引用实现的" class="headerlink" title="string是否是有引用实现的"></a>string是否是有引用实现的</h3><p>如果是引用实现的，在多线程条件下，可能因为要加锁所以带来性能上的影响，但是如果非引用实现，每个对象都是独立的copy则无影响。</p>
<h3 id="vector-的增长"><a href="#vector-的增长" class="headerlink" title="vector 的增长"></a>vector 的增长</h3><p>vector的每次增长都会耗费一定时间去拷贝原有数据，所以如果能够预计大小，则预先reserve(size)会更好</p>
<h3 id="vector赋值"><a href="#vector赋值" class="headerlink" title="vector赋值"></a>vector赋值</h3><p>最快的是用assign，其次是copy，最后是赋值操作符</p>
<h3 id="STL容器"><a href="#STL容器" class="headerlink" title="STL容器"></a>STL容器</h3><ul>
<li>迭代器(iterator) 实际上是一个指针所以</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::iterator it = &amp;svec[<span class="number">10</span>]</div></pre></td></tr></table></figure>
<p>是正确的</p>
<pre><code>*iter; //返回迭代器所指元素的引用
c.push_back(str); //新元素的值为str的副本
c.begin()/end(); //返回的是迭代器（即指针）
c.front()/back(); //返回的是元素的引用
</code></pre><ul>
<li>string可以看做为一个字符容器</li>
</ul>
<h3 id="Allocator"><a href="#Allocator" class="headerlink" title="Allocator"></a>Allocator</h3><p>虽然分配器的定制有所限制，但在许多情况下，仍需要用到自定义的分配器，而这一般是为封装对不同类型内存空间（如共享内存与已回收内存）的访问方式，或在使用内存池进行内存分配时提高性能而为。除此以外，从内存占用和运行时间的角度看，在频繁进行少量内存分配的程序中，若引入为之专门定制的分配器，也会获益良多。</p>
<p>任意满足分配器使用需求的C++类都可作分配器使用。具体来说，当一个类（在此设为类A）有为一个特定类型（在此设为类型T）的对象分配内存的能力时，该类就必须提供以下类型的定义：</p>
<ul>
<li>A::pointer 指针</li>
<li>A::const_pointer 常量指针</li>
<li>A::reference 引用</li>
<li>A::const_reference 常量引用</li>
<li>A::value_type 值类型</li>
<li>A::size_type 所用内存大小的类型，表示类A所定义的分配模型中的单个对象最大尺寸的无符号整型</li>
<li>A::difference_type 指针差值的类型，为带符号整型，用于表示分配模型内的两个指针的差异值。</li>
</ul>
<h3 id="map-unordered-map"><a href="#map-unordered-map" class="headerlink" title="map, unordered_map"></a>map, unordered_map</h3><p>如果key是一个对象，那么需要对此对象定义一个hash function</p>
<h3 id="STL-TIP"><a href="#STL-TIP" class="headerlink" title="STL TIP"></a>STL TIP</h3><ul>
<li>调用<code>empty()</code>去检查是否是空，而不是用<code>size()==0</code>检查</li>
<li><code>Vector&lt;bool&gt;</code>会变成bitset</li>
<li>巧用swap()可以出去vector中的多余容量</li>
<li>vector extend长度很耗时，可以事前<code>reserve()</code></li>
</ul>
<h3 id="std-function与std-bind-函数指针"><a href="#std-function与std-bind-函数指针" class="headerlink" title="std::function与std::bind 函数指针"></a>std::function与std::bind 函数指针</h3><p>function模板类和bind模板函数，使用它们可以实现类似函数指针的功能，但却却比函数指针更加灵活，特别是函数指向类 的非静态成员函数时。</p>
<p><code>std::function</code>可以绑定到全局函数/类静态成员函数(类静态成员函数与全局函数没有区别),如果要绑定到类的非静态成员函数，则需要使用<code>std::bind</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::function&lt;<span class="keyword">void</span> ()&gt; fp;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">g_fun</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"g_fun()"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">class</span> A</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">A_fun_static</span><span class="params">()</span></span></div><div class="line">	&#123;</div><div class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"A_fun_static()"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">A_fun</span><span class="params">()</span></span></div><div class="line">	&#123;</div><div class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"A_fun()"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">A_fun_int</span><span class="params">(<span class="keyword">int</span> i)</span></span></div><div class="line">	&#123;</div><div class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"A_fun_int() "</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//非静态类成员，因为含有this指针，所以需要使用bind</span></div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></div><div class="line">	&#123;</div><div class="line">		fp fp1=<span class="built_in">std</span>::bind(&amp;A::A_fun,<span class="keyword">this</span>);</div><div class="line">		fp1();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init2</span><span class="params">()</span></span></div><div class="line">	&#123;</div><div class="line">		<span class="keyword">typedef</span> <span class="built_in">std</span>::function&lt;<span class="keyword">void</span> (<span class="keyword">int</span>)&gt; fpi;</div><div class="line">		<span class="comment">//对于参数要使用占位符 std::placeholders::_1</span></div><div class="line">		fpi f=<span class="built_in">std</span>::bind(&amp;A::A_fun_int,<span class="keyword">this</span>,<span class="built_in">std</span>::placeholders::_1);</div><div class="line">		f(<span class="number">5</span>);</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="comment">//绑定到全局函数</span></div><div class="line">	fp f2=fp(&amp;g_fun);</div><div class="line">	f2();</div><div class="line"></div><div class="line">	<span class="comment">//绑定到类静态成员函数</span></div><div class="line">	fp f1=fp(&amp;A::A_fun_static);</div><div class="line">	f1();</div><div class="line"></div><div class="line">	A().init();</div><div class="line">	A().init2();</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同时，<code>std::bind</code>绑定到虚函数时会表现出多态行为。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::function&lt;<span class="keyword">void</span> ()&gt; fp;</div><div class="line"></div><div class="line"><span class="keyword">class</span> A</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></div><div class="line">	&#123;</div><div class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"A::f()"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></div><div class="line">	&#123;</div><div class="line">		<span class="comment">//std::bind可以表现出多态行为</span></div><div class="line">		fp f=<span class="built_in">std</span>::bind(&amp;A::f,<span class="keyword">this</span>);</div><div class="line">		f();</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">class</span> B:<span class="keyword">public</span> A</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></div><div class="line">	&#123;</div><div class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"B::f()"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	A* pa=<span class="keyword">new</span> B;</div><div class="line">	pa-&gt;init();</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="预处理注释代码"><a href="#预处理注释代码" class="headerlink" title="预处理注释代码"></a>预处理注释代码</h2><p><code>#if 0</code>可以用作注释一段代码，因为<code>/* */</code>不支持迭代，所以有时候用预处理方式更好</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></div><div class="line">	<span class="comment">//code</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<h2 id="new-operator-和-operator-new"><a href="#new-operator-和-operator-new" class="headerlink" title="new operator 和 operator new"></a>new operator 和 operator new</h2><ul>
<li><code>new operator</code> 就是我们经常在用的new，他会分配地址，构造对象，这个不能重构。（等同于<code>operator new</code>，之后调用构造函数）</li>
<li><code>operator new</code> 只分配内存，不构造对象，功能和malloc一样，可以重构。</li>
<li>placement new 在已有的空间上，构造对象</li>
</ul>
<h2 id="operator重载"><a href="#operator重载" class="headerlink" title="operator重载"></a>operator重载</h2><p>重载有两种方法，一种是在类中对于类的操作符重载，另外一种是全局重载，全局重载有一个条件，就是参数至少有一个是自定义类型，这个是C++标准特别限制的</p>
<ul>
<li><code>b.operator+(a)</code>等同于<code>b+a</code>, 等同于operator+(b,a)<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> <span class="keyword">operator</span>+(Factor &amp;lhs, <span class="keyword">int</span> rhs)&#123;</div><div class="line">    <span class="comment">//do something</span></div><div class="line">    <span class="keyword">return</span> lhs.<span class="keyword">get</span>() + rhs;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//下面的方法是错误的</span></div><div class="line"><span class="keyword">int</span> <span class="keyword">operator</span>+(Int lhs, <span class="keyword">int</span> rhs)&#123;</div><div class="line">    <span class="comment">//do something</span></div><div class="line">    <span class="keyword">return</span> lhs + rhs;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//类中重载的例子</span></div><div class="line"><span class="keyword">class</span> <span class="title">cls</span>&#123;</div><div class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>+(cls &amp;rhs)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span> + rhs;    </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="解决-static-属性的初始化赋值问题"><a href="#解决-static-属性的初始化赋值问题" class="headerlink" title="解决 static 属性的初始化赋值问题"></a>解决 static 属性的初始化赋值问题</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">c1</span></span>&#123;</div><div class="line">  <span class="keyword">private</span>：</div><div class="line">    <span class="keyword">static</span> const size_t <span class="built_in">max</span> = <span class="number">10</span>;</div><div class="line">&#125; <span class="comment">//此种方法是通常不允许的</span></div><div class="line"></div><div class="line"><span class="comment">//可以采用以下workaround</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">c1</span></span>&#123;</div><div class="line">  <span class="keyword">private</span>：</div><div class="line">    <span class="keyword">static</span> const size_t <span class="built_in">max</span>;</div><div class="line">&#125;</div><div class="line">const size_t c1::<span class="built_in">max</span> =<span class="number">10</span>;</div><div class="line"></div><div class="line"><span class="comment">//或者</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">c1</span></span>&#123;</div><div class="line">  <span class="keyword">private</span>：</div><div class="line">    <span class="class"><span class="keyword">enum</span></span>&#123; <span class="built_in">max</span> = <span class="number">10</span>&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><h3 id="operator-char-const"><a href="#operator-char-const" class="headerlink" title="operator char() const"></a>operator char() const</h3><p>这是一个类型转换的操作符</p>
<h2 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h2><h3 id="inline函数不一定inline"><a href="#inline函数不一定inline" class="headerlink" title="inline函数不一定inline"></a>inline函数不一定inline</h3><ul>
<li>他只是给编译器的一个建议，inline函数中不建议有循环指令</li>
<li>在类的声明中实现的类（头文件中），默认就为inline函数</li>
<li>不建议inline 和 static 一起使用，因为会造成大量internal副本。最新版本的C++编译器已经修复此问题。</li>
</ul>
<h3 id="尽量以引用和指针方式传参"><a href="#尽量以引用和指针方式传参" class="headerlink" title="尽量以引用和指针方式传参"></a>尽量以引用和指针方式传参</h3><ul>
<li>这样可以减少对象被构造和解析的过程</li>
<li>尽量推迟变量声明的时间</li>
</ul>
<h3 id="itr-和-itr"><a href="#itr-和-itr" class="headerlink" title="itr++ 和 ++itr"></a>itr++ 和 ++itr</h3><p>在不考虑返回值的时候<code>++itr</code>效率更高，因为他不需要做一次数据拷贝，对于基本类型可以忽略，对于Class和迭代器，尽量使用前置自增（减）<br>所以++++itr合法，而itr++++不合法</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//前置</span></div><div class="line">UPInt&amp; UPInt::<span class="keyword">operator</span>++()&#123;</div><div class="line">    *<span class="keyword">this</span>+= <span class="number">1</span>;</div><div class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//后置</span></div><div class="line">UPInt&amp; UPInt::<span class="keyword">operator</span>++(int)&#123;</div><div class="line">    UPInt oldValue = *<span class="keyword">this</span>;</div><div class="line">	++(*<span class="keyword">this</span>);</div><div class="line">	<span class="keyword">return</span> oldValue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="using"><a href="#using" class="headerlink" title="using"></a>using</h3><p>如果子类中的属性或者局部变量的名称与父类的重名，可以用using指定使用哪个</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> base::m_attr;</div></pre></td></tr></table></figure>
<h3 id="纯虚函数可以有实现"><a href="#纯虚函数可以有实现" class="headerlink" title="纯虚函数可以有实现"></a>纯虚函数可以有实现</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span></span>&#123;</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    vitural bool <span class="function"><span class="keyword">func</span><span class="params">()</span></span> = <span class="number">0</span>;</div><div class="line">	....</div><div class="line">&#125;</div><div class="line">bool base::<span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="comment">//something</span></div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">derived</span> : <span class="title">public</span> <span class="title">base</span></span>&#123;</div><div class="line">  </div><div class="line">&#125;</div><div class="line">derived* d = new derived();</div><div class="line">d-&gt;base::<span class="function"><span class="keyword">func</span><span class="params">()</span></span>; <span class="comment">//调用纯虚函数的默认实现</span></div></pre></td></tr></table></figure>
<h3 id="mutable-作用"><a href="#mutable-作用" class="headerlink" title="mutable 作用"></a>mutable 作用</h3><p>mutable修饰过的属性，即便在const函数中也可以被修改。另外我们也有另一种办法来实现，就是通过一个fake this指针，在const函数中，把const this指针cast成 this，这样就可以通过这个fake this指针做赋值操作了</p>
<h3 id="const-调用规则"><a href="#const-调用规则" class="headerlink" title="const 调用规则"></a>const 调用规则</h3><p>类中二函数都存在的情况下：</p>
<ul>
<li>const对象默认调用const成员函数，非const对象默认调用非const成员函数；</li>
<li>若非const对象想调用const成员函数，则需显式转化，如(const Student&amp;)obj.getAge();</li>
<li>若const对象想调用非const成员函数，同理const_cast<student&>(constObj).getAge();(注意：constObj要加括号)</student&></li>
</ul>
<p>类中只有一函数存在的情况下：</p>
<ul>
<li>非const对象可以调用const成员函数或非const成员函数；</li>
<li>const对象只能调用const成员函数,直接调用非const函数时编译器会报错；</li>
</ul>
<h3 id="指针和引用"><a href="#指针和引用" class="headerlink" title="指针和引用"></a>指针和引用</h3><p>引用不可以为空，如果变量需要为空，则要用指针，如果希望不为空则尽量用引用，避免了不必要的验NULL检查</p>
<h3 id="绝对不要以多态（Polymorphically）方式处理数组"><a href="#绝对不要以多态（Polymorphically）方式处理数组" class="headerlink" title="绝对不要以多态（Polymorphically）方式处理数组"></a>绝对不要以多态（Polymorphically）方式处理数组</h3><p>数组的基本原理是依靠数组下标来寻找对应的对象，所以在多态情况下，跳过的指针偏移不一样，所以用Base指正来使用Derived类数组会有错误。</p>
<h3 id="避免类中Implicit的类型装换函数"><a href="#避免类中Implicit的类型装换函数" class="headerlink" title="避免类中Implicit的类型装换函数"></a>避免类中Implicit的类型装换函数</h3><p>Implicit的类型转换（或者重载操作符），如果出现任何问题会非常难调试，所以尽量显示的进行类型转换，比如<code>o.asInt()</code>, <code>o.asDouble()</code>这样输出。或者以explicit修饰构造函数。</p>
<h3 id="复合操作符（-）"><a href="#复合操作符（-）" class="headerlink" title="复合操作符（+=）"></a>复合操作符（+=）</h3><p>复合操作符（+=）比单独操作符效率要高，不需要产生临时变量</p>
<h3 id="size-t"><a href="#size-t" class="headerlink" title="size_t"></a>size_t</h3><p>size_t 解决了在不同系统32、64位系统上 strlen类型大小的问题， 32bit系统strlen返回4字节的值，而64是8字节</p>
<h3 id="全局符号"><a href="#全局符号" class="headerlink" title="全局符号"></a>全局符号</h3><p>全局符号<code>::</code>表示调用global的变量或者方法，也适用于如下情况<br><figure class="highlight subunit"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//如果test类重构了operator new，则`::new`表示使用默认的new构造，而不是重构之后的</div><div class="line"><span class="keyword">test </span>t = ::new test();</div></pre></td></tr></table></figure></p>
<h2 id="fork-execl"><a href="#fork-execl" class="headerlink" title="fork execl"></a>fork execl</h2><ul>
<li>fork 会复制父进程的所有资源，包括文件描述符，会建立一个全新的pid，他的文件描述符复制父进程的</li>
<li>execl 会开始一个全新的程序全面覆盖父进程，但是他的pid依旧是是他父进程的pid，他也会继续share父进程已经打开的文件描述符，popen实际上就是调用了这个来运行一个新的程序。execl一旦运行 execl后面的code将不会被执行了，因为已经被覆盖掉了</li>
<li>vfork 父子空间共享内存空间，使得由子函数调用vfork创建的子进程（架设子进程为先执行函数的进程）调用其它函数或运行其他程序后会，父进程会出现段错误，</li>
</ul>
<h2 id="dup-dup2"><a href="#dup-dup2" class="headerlink" title="dup dup2"></a>dup dup2</h2><p>使newfd指向fd的文件</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span><span class="type">fd</span> = dup(fd)</div><div class="line">dup(fd,<span class="keyword">new</span><span class="type">fd</span>)</div></pre></td></tr></table></figure>
<h2 id="strncpy-and-snprintf"><a href="#strncpy-and-snprintf" class="headerlink" title="strncpy and snprintf"></a>strncpy and snprintf</h2><ul>
<li>strncpy：如果字符串超过 size n， 那么他不会再字符串结尾加上\0</li>
<li>snprintf: 如果字符串超出 n，他会在最后一个字符加上\0， 所以这个更安全</li>
<li><code>strncat(char *dest, const char *src, size_t n)</code>: 最多从源中拷贝n个字符到目标串中，并在后面加一个0；也就是说，最多会有n+1个字符被写进dest。如果dest的容量为n，那么将会dest将会溢出。</li>
</ul>
<h2 id="execl与execlp的区别"><a href="#execl与execlp的区别" class="headerlink" title="execl与execlp的区别"></a>execl与execlp的区别</h2><ul>
<li>execl只当前路径（不是当前路径必须加绝对路径）</li>
<li>execlp使用系统的搜索路径</li>
<li>带l的exec函数：execl,execlp,execle，表示后边的参数以可变参数的形式给出且都以一个空指针结束。</li>
<li>带 p的exec函数：execlp,execvp，表示第一个参数path不用输入完整路径，只有给出命令名即可，它会在环境变量PATH当中查找命令</li>
<li>不带l的exec函数：execv,execvp表示命令所需的参数以char *arg[]形式给出且arg最后一个元素必须是NULL</li>
<li>带e的exec函数：execle表示，将环境变量传递给需要替换的进程</li>
</ul>
<h3 id="system"><a href="#system" class="headerlink" title="system()"></a>system()</h3><p>system函数对返回值的处理，涉及3个阶段：</p>
<ul>
<li>阶段1：创建子进程等准备工作。如果失败，返回-1。</li>
<li>阶段2：调用/bin/sh拉起shell脚本,如果拉起失败或者shell未正常执行结束，原因值被写入到status的低8~15比特位中。system的man中只说明了会写了127这个值, 但实测发现还会写126等值。</li>
<li>阶段3：如果shell脚本正常执行结束，将shell返回值填到status的低8~15比特位中。</li>
</ul>
<p>判断一个system函数调用shell脚本是否正常结束的方法应该是如下3个条件同时成立：</p>
<ol>
<li>-1 != status</li>
<li>WIFEXITED(status)为真</li>
<li>0 == WEXITSTATUS(status)</li>
</ol>
<h2 id="setbuf"><a href="#setbuf" class="headerlink" title="setbuf()"></a>setbuf()</h2><p>函数setbuf()用于将指定缓冲区与特定的文件流相关联，实现操作缓冲区时直接操作文件流的功能。其原型如下：<br>    <code>void setbuf(FILE * stream, char * buf);</code></p>
<h2 id="unlink"><a href="#unlink" class="headerlink" title="unlink()"></a>unlink()</h2><p><code>unlink(char* filename)</code>用于删除link，如果没有任何link，且所有操作这个文件的fd已经关闭，unlink会删除文件, 这是个古老的UNIX方法</p>
<h2 id="unordered-map-和-map"><a href="#unordered-map-和-map" class="headerlink" title="unordered_map 和 map"></a>unordered_map 和 map</h2><p>unordered_map 要比 map更快，同样是唯一键值，如果只关心键值，可以使用unordered_set</p>
<h2 id="多态和类型转换"><a href="#多态和类型转换" class="headerlink" title="多态和类型转换"></a>多态和类型转换</h2><p>考虑如下程序</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">class</span> A</div><div class="line">&#123;</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">     <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></div><div class="line">     &#123;</div><div class="line">	 <span class="built_in">printf</span>(<span class="string">"A::f()\n"</span>);</div><div class="line">     &#125;</div><div class="line">    </div><div class="line">     <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span></div><div class="line">     &#123;</div><div class="line"> 	<span class="comment">//printf("A::g(), %d\n",a);</span></div><div class="line"> 	<span class="built_in">printf</span>(<span class="string">"A::g()\n"</span>);</div><div class="line">     &#125;</div><div class="line">     </div><div class="line">     <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span> a)</span></span></div><div class="line">     &#123;</div><div class="line"> 	<span class="built_in">printf</span>(<span class="string">"A::g(), %d\n"</span>,a);</div><div class="line"> 	<span class="comment">//printf("A::g()\n");</span></div><div class="line">        g();</div><div class="line">     &#125;</div><div class="line">    </div><div class="line">     <span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">()</span> </span></div><div class="line">     &#123;</div><div class="line">	 <span class="built_in">printf</span>(<span class="string">"A::h()\n"</span>);</div><div class="line">         f(); </div><div class="line">         g(); </div><div class="line">     &#125;</div><div class="line">     </div><div class="line">     <span class="comment">//virtual</span></div><div class="line">     ~A()&#123;<span class="built_in">printf</span>(<span class="string">"destruct A\n"</span>);&#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">class</span> B: <span class="keyword">public</span> A</div><div class="line">&#123;</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">using</span> A::g; \\ <span class="keyword">this</span> C++<span class="number">11</span> <span class="function">keyword can make the derived <span class="keyword">class</span> call a redefinited base <span class="keyword">class</span> function</span></div><div class="line">     <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></div><div class="line">    &#123; <span class="built_in">printf</span>(<span class="string">"B::f()\n"</span>);&#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span></div><div class="line">    &#123;<span class="built_in">printf</span>(<span class="string">"B::g()\n"</span>);&#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">()</span></span></div><div class="line">    &#123;<span class="built_in">printf</span>(<span class="string">"B::h()\n"</span>);g();f();&#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">u</span><span class="params">()</span></span></div><div class="line">    &#123;<span class="built_in">printf</span>(<span class="string">"B::u()\n"</span>);&#125;</div><div class="line">    </div><div class="line">     <span class="comment">//virtual</span></div><div class="line">     ~B()&#123;<span class="built_in">printf</span>(<span class="string">"destruct B\n"</span>);&#125;</div><div class="line"></div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    B b;</div><div class="line">    <span class="comment">//b.g(1);</span></div><div class="line">    A * p=&amp;b;</div><div class="line">    A* p1 = <span class="keyword">new</span> B();</div><div class="line">    p-&gt;h();</div><div class="line">    p-&gt;g();</div><div class="line">    p-&gt;g(<span class="number">2</span>);</div><div class="line">    A *a = <span class="keyword">dynamic_cast</span>&lt;A*&gt;(&amp;b);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</div><div class="line">    a-&gt;h();</div><div class="line">    a-&gt;g();</div><div class="line">    a-&gt;g(<span class="number">2</span>);</div><div class="line">    <span class="comment">//a-&gt;u();</span></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</div><div class="line">    B* pb = &amp;b;</div><div class="line">    pb-&gt;g(<span class="number">2</span>);</div><div class="line">    pb-&gt;g();</div><div class="line"></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</div><div class="line">    <span class="keyword">delete</span> p1;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对应输出为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">A::h()</div><div class="line">B::f()</div><div class="line">B::g()</div><div class="line">B::g()</div><div class="line">A::g(), <span class="number">2</span></div><div class="line">B::g()</div><div class="line"></div><div class="line">A::h()</div><div class="line">B::f()</div><div class="line">B::g()</div><div class="line">B::g()</div><div class="line">A::g(), <span class="number">2</span></div><div class="line">B::g()</div><div class="line"></div><div class="line">A::g(), <span class="number">2</span></div><div class="line">B::g()</div><div class="line">B::g()</div><div class="line"></div><div class="line">destruct A</div><div class="line">destruct B</div><div class="line">destruct A</div></pre></td></tr></table></figure>
<p>结论</p>
<ul>
<li>如果不是虚函数，指针类型的转换会导致调用对应类型的种的函数，即不为多态</li>
<li>如果是虚函数则，按照多态显示</li>
<li>如果是虚函数调用所在子类的非虚函数或者虚函数，则调用的都是子类中的函数，即便是非虚函数也不会调用到父类中的对应函数</li>
<li>如果Base指针去访问一个子类中的非虚函数，则编译报错 </li>
<li>如果子类有父类的同名函数（不论是否是虚函数），则父类的所有同名的函数都被redefine（不同参数的），<code>using</code>keyword可以改进这个问题，<code>using A::g()</code>可以使B调用到<code>A::g()</code>，但是如果B已经有了g()，则无效?, 直接用<code>Base::f()</code>可以調用到父類的方法，但是this指针还是子类的，所以多台依旧</li>
<li>如果不是new出的对象不用考虑析构问题，系统可以很好的析构父类和子类</li>
<li>如果是new，需要虚析构函数，以保证父类指针也能正常析构一个指向子类的对象</li>
</ul>
<h2 id="C-11"><a href="#C-11" class="headerlink" title="C++11"></a>C++11</h2><h3 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h3><p>注意auto使用不当会导致vector被复制，而不是被引用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</div><div class="line"> </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span> &amp;i : v) <span class="comment">// access by const reference</span></div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span>;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</div><div class="line"> </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : v) <span class="comment">// access by value, the type of i is int</span></div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span>;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</div><div class="line"> </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; i : v) <span class="comment">// access by reference, the type of i is int&amp;</span></div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span>;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</div><div class="line"> </div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n : &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;) <span class="comment">// the initializer may be a braced-init-list</span></div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">' '</span>;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Range-based-for-loop"><a href="#Range-based-for-loop" class="headerlink" title="Range-based for loop"></a>Range-based for loop</h3><p>此方法常用语STL中内容的遍历，注意使用不当会导致容器中对象被复制 最佳用法是 <code>for (auto&amp; elem : range)</code>， 对于性能这和手动写的没什么区别。</p>
<p><code>for (auto elem : range)</code> is very tempting and very bad. It produces <code>auto elem = *__begin;</code> (see 6.5.4 [stmt.ranged]/1), which copies each element, which is bad because:</p>
<ul>
<li>It might not compile - for example, unique_ptr elements aren’t copyable. This is problematic both for users who won’t understand the resulting compiler errors, and for users writing generic code that’ll happily compile until someone instantiates it for movable-only elements.</li>
<li>It might misbehave at runtime - for example, “elem = val;” will modify the copy, but not the original element in the range. Additionally, &amp;elem will be invalidated after each iteration.</li>
<li>It might be inefficient - for example, unnecessarily copying std::string.</li>
</ul>
<h2 id="重写-重载"><a href="#重写-重载" class="headerlink" title="重写 重载"></a>重写 重载</h2><p>如果父类定义了一个g(int)，子类定义了一个g()，那么用子类的对象访问g(int)那么会编译出错，因为子类定义的g()函数覆盖了g(int)所以子类不能访问。<br>如果父类定义了一个virtual g(int)，子类定义了一个virtualg()，那么用子类的对象访问(用.访问)virtual g(int)那么会编译出错，因为子类定义的virtual g()函数覆盖了virtual g(int)所以子类不能访问， 但是如果用指针（-&gt;）访问则会得到预期结果<br>override-&gt;重写(=覆盖)、overload-&gt;重载、polymorphism -&gt; 多态</p>
<ul>
<li><p>重定义（redefining）也叫隐藏，子类重新定义父类中的非虚函数，屏蔽了父类的同名函数</p>
<ul>
<li>子类和父类的函数名称相同，但参数不同，此时不管父类函数是不是virtual函数，都将被隐藏(如果不用父类指针访问的话)。</li>
<li>子类和父类的函数名称相同，参数也相同，但是父类函数不是virtual函数，父类的函数将被隐藏。</li>
<li>using Base::f 可以手动指定使用哪个函数（子类父类会保留下来）子类和父类冲突时，保留父类的</li>
</ul>
</li>
<li>重写（override）也称为覆盖，子类重新定义父类中有相同名称和参数的虚函数，主要在继承关系中出现。</li>
<li>重载（overload）函数有同样的名称，但是参数列表不相同的情形，这样的同名不同参数的函数之间，互相称之为重载函数。</li>
</ul>
<p><em>NOTICE</em> 除了赋值运算符重载函数以外，所有的运算符重载函数都可以被派生类继承。也就是说复制运算操作符不能被继承</p>
<h2 id="attribute-constructor"><a href="#attribute-constructor" class="headerlink" title="attribute ((constructor))"></a><strong>attribute</strong> ((constructor))</h2><p> gcc为函数提供了几种类型的属性，其中包含：构造函数(constructors)和析构函数(destructors)。<br>程序员应当使用类似下面的方式来指定这些属性：<br>    static void start(void) <strong>attribute</strong> ((constructor));<br>    static void stop(void) <strong>attribute</strong> ((destructor));<br>带有”构造函数”属性的函数将在main()函数之前或者动态库被load之前被执行，而声明为”析构函数”属性的函数则将在main()或者动态库unload的时候退出时执行。</p>
<ul>
<li>reference：<a href="https://gcc.gnu.org/onlinedocs/gcc/Common-Function-Attributes.html#Common-Function-Attributes" target="_blank" rel="external">https://gcc.gnu.org/onlinedocs/gcc/Common-Function-Attributes.html#Common-Function-Attributes</a></li>
</ul>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h3><ul>
<li>注意互斥量的粒度，通常来讲对于一个变量就要对应一个互斥量，这是最优方案，另外可以增加粒度比如多个变量对应同一个互斥量，这样会影响效率，如果允许可以这样</li>
<li>互斥量尽量存在于基类中，这样对于使用者是透明的。</li>
</ul>
<h3 id="pthread-attr-setscope"><a href="#pthread-attr-setscope" class="headerlink" title="pthread_attr_setscope"></a>pthread_attr_setscope</h3><p>pthread_attr_setscope函数的作用是设置线程的在什么范围内竞争CPU资源，可以取值PTHREAD_SCOPE_SYSTEM或PTHREAD_SCOPE_PROCESS，前者表示在整个系统内竞争CPU资源，后者表示在同一进程内竞争CPU资源，默认为前者，原型如下：<br><code>int pthread_attr_setscope(pthread_attr_t *attr, int scope);</code></p>
<h3 id="pthread-attr-setstacksize"><a href="#pthread-attr-setstacksize" class="headerlink" title="pthread_attr_setstacksize"></a>pthread_attr_setstacksize</h3><p>设置线程栈的大小, 单位是字节，在默认情况下线程的栈是比较大的</p>
<h3 id="pthread-attr-setdetachstate"><a href="#pthread-attr-setdetachstate" class="headerlink" title="pthread_attr_setdetachstate"></a>pthread_attr_setdetachstate</h3><p>pthread_attr_setdetachstate函数的作用是设置线程的detachedstate属性，可以取值PTHREAD_CREATE_JOINABLE和PTHREAD_CREATE_DETACHED，前者是默认值，表示其他线程可以使用pthread_join函数等待本线程结束，后者表示其他线程不可以对本线程使用pthread_join</p>
<h3 id="pthread-attr-setschedpolicy"><a href="#pthread-attr-setschedpolicy" class="headerlink" title="pthread_attr_setschedpolicy"></a>pthread_attr_setschedpolicy</h3><p>pthread_attr_setschedpolicy函数的作用是设置schedpolicy属性，即线程调度算法。schedpolicy属性值可以是SCHED_RR、SCHED_FIFO、SCHED_OTHER，其中SCHED_RR表示轮训调度，SCHED_FIFO表示先进先出调度，SCHED_OTHER表示其他。拥有管理员权限的进程才可以创建具有SCHED_RR或SCHED_FIFO调度算法的线程，一般线程的默认调度算法都是SCHED_OTHER。</p>
<h3 id="pthread-once"><a href="#pthread-once" class="headerlink" title="pthread_once"></a>pthread_once</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">int</span> pthread_once(pthread_once_t *once_control, </div><div class="line">    <span class="keyword">void</span> (*init_routine)(<span class="keyword">void</span>));</div><div class="line">pthread_once_t once_control = PTHREAD_ONCE_INIT;</div></pre></td></tr></table></figure>
<p>The first call to pthread_once() by any thread in a process, with a given once_control, will call the init_routine() with no arguments. Subsequent calls of pthread_once() with the same once_control will not call the init_routine(). On return from pthread_once(), it is guaranteed that init_routine() has completed. The once_control parameter is used to determine whether the associated initialisation routine has been called.<br>The function pthread_once() is not a cancellation point. However, if init_routine() is a cancellation point and is canceled, the effect on once_control is as if pthread_once() was never called.</p>
<p>The constant PTHREAD_ONCE_INIT is defined by the header <pthread.h>.</pthread.h></p>
<p>The behaviour of pthread_once() is undefined if once_control has automatic storage duration or is not initialised by PTHREAD_ONCE_INIT.</p>
<h3 id="pthread-cond-signal"><a href="#pthread-cond-signal" class="headerlink" title="pthread_cond_signal()"></a>pthread_cond_signal()</h3><p>也要配合mutex来使用，不然会可能丢失signal，考虑如下：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Process A                             Process B</div><div class="line"></div><div class="line">pthread_mutex_lock(<span class="name">&amp;mutex</span>)<span class="comment">;</span></div><div class="line">while (<span class="name">condition</span> == FALSE)</div><div class="line"></div><div class="line">                                      condition = TRUE<span class="comment">;</span></div><div class="line">                                      pthread_cond_signal(<span class="name">&amp;cond</span>)<span class="comment">;</span></div><div class="line"></div><div class="line">pthread_cond_wait(<span class="name">&amp;cond</span>, <span class="symbol">&amp;mutex</span>)<span class="comment">;</span></div></pre></td></tr></table></figure>
<p>如果刚好是这个情形，那么由于B没加锁，那么本来符合条件的A也再次被阻塞</p>
<h3 id="fseek-线程不安全"><a href="#fseek-线程不安全" class="headerlink" title="fseek 线程不安全"></a>fseek 线程不安全</h3><p>可考虑用pread，替代fseek和fread组合</p>
<h3 id="strtok"><a href="#strtok" class="headerlink" title="strtok()"></a>strtok()</h3><p>strtok是一个线程不安全的函数，他的安全版本是strtok_r()</p>
<h2 id="网络和进程通信"><a href="#网络和进程通信" class="headerlink" title="网络和进程通信"></a>网络和进程通信</h2><h3 id="readv-和writev"><a href="#readv-和writev" class="headerlink" title="readv()和writev()"></a>readv()和writev()</h3><p>这两个函数类似于read和write，不过readv和writev允许单个系统调用读入到或写出自一个或多个缓冲区。这些操作分别称为分散读（scatter read）和集中写（gather write），因为来自读操作的输入数据被分散到多个应用缓冲区中，而来自应用缓冲区的输出数据则被集中提供给单个写操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/uio.h&gt;</span></span></div><div class="line"><span class="keyword">ssize_t</span> readv(<span class="keyword">int</span> filedes, <span class="keyword">const</span> <span class="keyword">struct</span> iovec *iov, <span class="keyword">int</span> iovcnt);</div><div class="line"><span class="keyword">ssize_t</span> writev(<span class="keyword">int</span> filedes, <span class="keyword">const</span> <span class="keyword">struct</span> iovec *iov, <span class="keyword">int</span> iovcnt);</div><div class="line"></div><div class="line"><span class="keyword">struct</span> iovec &#123;</div><div class="line">    <span class="keyword">void</span>     *iov_base;       <span class="comment">/* starting address of buffer */</span></div><div class="line">    <span class="keyword">size_t</span>    iov_len;        <span class="comment">/* size of buffer */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>当服务器close了一个连接之后，如果client接着发送数据，会收到一个RST相应，client再发送数据时，就会收到一个SIGPIPE给进程，默认动作是结束client进程，我们可以使用如下方法来指定信号的处理</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></div><div class="line"></div><div class="line">signal(SIGPIPE, SIG_IGN)<span class="comment">;</span></div><div class="line">signal(SIGCHLD, SIG_IGN)<span class="comment">;</span></div></pre></td></tr></table></figure>
<h3 id="read-and-write"><a href="#read-and-write" class="headerlink" title="read and write"></a>read and write</h3><p>他们有不同的buffer，所以是全双工运行， </p>
<ul>
<li>read返回0：表示连接关闭，或者说EOF</li>
<li>read返回&lt;0: 表示发生错误，check errno</li>
</ul>
<h3 id="DNS-Lookup"><a href="#DNS-Lookup" class="headerlink" title="DNS Lookup"></a>DNS Lookup</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span></span> *gethostbyname(<span class="keyword">const</span> <span class="keyword">char</span> *name);</div><div class="line"><span class="keyword">int</span> gethostbyname_r(<span class="keyword">const</span> <span class="keyword">char</span> *name,</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span></span> *ret, <span class="keyword">char</span> *buf, size_t buflen,</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span></span> **result, <span class="keyword">int</span> *h_errnop);</div><div class="line">	</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span></span> &#123;</div><div class="line">	<span class="keyword">char</span>  *h_name;            <span class="comment">/* official name of host */</span></div><div class="line">	<span class="keyword">char</span> **h_aliases;         <span class="comment">/* alias list */</span></div><div class="line">	<span class="keyword">int</span>    h_addrtype;        <span class="comment">/* host address type */</span></div><div class="line">	<span class="keyword">int</span>    h_length;          <span class="comment">/* length of address */</span></div><div class="line">	<span class="keyword">char</span> **h_addr_list;       <span class="comment">/* list of addresses */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>gethostbyname_r</code>线程安全，<code>gethostbyname</code>不是线程安全的。</p>
<h3 id="Network-Address-Convert"><a href="#Network-Address-Convert" class="headerlink" title="Network Address Convert"></a>Network Address Convert</h3><pre><code>const char *inet_ntop(int af, const void *src,
                         char *dst, socklen_t size);
</code></pre><ul>
<li>This function converts the network address structure src in the af address family into a character string.  The resulting string is copied to the buffer pointed to by dst, which must be a non-NULL pointer.  The caller specifies the number of bytes available in this  buffer in the argument size.</li>
<li>与此相似的还有<code>inet_ntoa</code>, 但是他是线程不安全的。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_pton</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">const</span> <span class="keyword">char</span> *src, <span class="keyword">void</span> *dst)</span></span>;</div></pre></td></tr></table></figure>
<p>反向转换</p>
<h3 id="多种sockaddr"><a href="#多种sockaddr" class="headerlink" title="多种sockaddr"></a>多种sockaddr</h3><ul>
<li>struct sockaddr</li>
<li>struct sockaddr_in</li>
<li>struct sockaddr_storage</li>
</ul>
<h3 id="网络字节序"><a href="#网络字节序" class="headerlink" title="网络字节序"></a>网络字节序</h3><ul>
<li>htons</li>
<li>ntohs</li>
<li>htonl</li>
<li>ntohl</li>
</ul>
<h2 id="类内初始化和初始化列表"><a href="#类内初始化和初始化列表" class="headerlink" title="类内初始化和初始化列表"></a>类内初始化和初始化列表</h2><p>好像C++11之后就支持类内初始化了，在之前类内初始化是不允许的</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> <span class="title">A</span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">7</span>; <span class="comment">//C++98允许</span></div><div class="line">    <span class="keyword">int</span> b = <span class="number">8</span>; <span class="comment">//C++11允许，而98不允许</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>如果两者同时出现 那么初始化列表会覆盖类内初始化</li>
</ul>
<h2 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">class</span> <span class="selector-tag">A</span>&#123;</div><div class="line"><span class="attribute">public</span>:</div><div class="line">    void <span class="built_in">print</span>()&#123;</div><div class="line">    //</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">class</span> <span class="selector-tag">B</span>&#123;</div><div class="line"><span class="attribute">public</span>:</div><div class="line">    void <span class="built_in">print</span>()&#123;</div><div class="line">    //</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">class</span> <span class="selector-tag">C</span><span class="selector-pseudo">:public</span> <span class="selector-tag">A</span>, <span class="selector-tag">B</span>&#123;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如上例子如果我们使用c.print就会出现二义性的问题，采用虚继承可以解决这个问题</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:<span class="title">public</span> <span class="title">virtual</span> <span class="title">A</span>, <span class="title">B</span></span>&#123;</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line">int main()&#123;</div><div class="line">    <span class="type">C</span> <span class="built_in">c</span>();</div><div class="line">    <span class="built_in">c</span>.<span class="built_in">print</span>()</div><div class="line"></div><div class="line">    <span class="built_in">c</span>.<span class="type">A</span>::<span class="built_in">print</span>()<span class="comment">//可以指定使用哪个版本</span></div><div class="line">    <span class="built_in">c</span>.<span class="type">B</span>::<span class="built_in">print</span>()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Deamon"><a href="#Deamon" class="headerlink" title="Deamon"></a>Deamon</h2><p>一个守护进程需要fork两次，并且调用setsid()，两次是为了摆脱终端对于程序生命周期的控制，使其成为init 1进程的子进程，setsid会设置一个新的回话，不然进程会随着本回话的退出而结束。<br>The second fork(2) is there to ensure that the new process is not a session leader。</p>
<h2 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h2><ul>
<li>mmap allows all those processes to share the same physical memory pages, saving a lot of memory.</li>
<li>在swap的时候，如果是使用malloc的部分要交换到swap区，但是如果是mmap则不用，因为他可以找到对应文件，在swap back的时候可以重新映射，这在处理大文件的时候非常有用</li>
<li>限制是，如果是32位的系统，地址空间有限</li>
<li>不会拷贝到内存空间，不论是不论是物理内存还是虚拟内存，但是占用地址</li>
</ul>
<h2 id="删除一个已经打开的文件"><a href="#删除一个已经打开的文件" class="headerlink" title="删除一个已经打开的文件"></a>删除一个已经打开的文件</h2><ul>
<li><p>If the file is moved (in the same filesystem) or renamed, then the file handle remains open and can still be used to read and write the file.</p>
</li>
<li><p>If the file is deleted, the file handle remains open and can still be used (This is not what some people expect). The file will not really be deleted until the last handle is closed.</p>
</li>
<li><p>If the file is replaced by a new file, it depends exactly how. Either the file is overwritten, in which case the file handle will still be valid and access the new file, or the existing file is unlinked and a new one created with the same name, in which case it’s the same as deletion (see above).</p>
</li>
<li><p>In general, once the file is open, the file is open, and nobody changing the directory structure can change that - they can move, rename the file, or put something else in its place, it simply remains open.</p>
</li>
</ul>
<h2 id="typename"><a href="#typename" class="headerlink" title="typename"></a>typename</h2><p>泛型编程中，经常出现泛型和变量混淆的情况例如<code>FooClass::type * p</code>，这里的歧义是，到底是声明一个指针，还是做乘法，这个时候我们就可以显示的告诉他<code>typename FooClass::type* p</code></p>
<h2 id="泛型的实例化和特例化"><a href="#泛型的实例化和特例化" class="headerlink" title="泛型的实例化和特例化"></a>泛型的实例化和特例化</h2><ul>
<li>由于泛型是在编译期间，由编译器生成类或者函数的，所以编译器需要知道类或者方法的定义，不仅仅只是声明</li>
<li>特例化发生在，模板类不能被直接套用的时候，用<code>tempalate &lt;&gt;</code>特例化一个模板</li>
</ul>
<h2 id="extern-“C”"><a href="#extern-“C”" class="headerlink" title="extern “C”"></a>extern “C”</h2><p>理论上我们在写C++程序的时候调用C标准库都需要告诉编译器这些C标准库的函数需要<code>extern C</code>，但是实际上标准库都为我们做好了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></div><div class="line"><span class="keyword">extern</span> <span class="string">"C"</span>&#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="comment">//declare.</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></div><div class="line">&#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<h2 id="ranged-for"><a href="#ranged-for" class="headerlink" title="ranged-for"></a>ranged-for</h2><p>下面两者等同</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">RecordMap&lt;T&gt; replica_map;</div><div class="line"><span class="keyword">for</span>(auto&amp; itr : replica_map)&#123;&#125;</div><div class="line"><span class="keyword">for</span>(typename RecordMap&lt;T&gt;<span class="symbol">:</span><span class="symbol">:iterator</span><span class="symbol">:</span><span class="symbol">:value_type&amp;</span> itr : replica_map)&#123;&#125;</div></pre></td></tr></table></figure>
<h2 id="另类Singleton"><a href="#另类Singleton" class="headerlink" title="另类Singleton"></a>另类Singleton</h2><p>The friend declaration appears in a class body and grants a function or another class access to private and protected members of the class where the friend declaration appears.<br><figure class="highlight gauss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Writer</span>* getWriter()&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Writer</span>();</div><div class="line">&#125;</div><div class="line"></div><div class="line">class <span class="built_in">Writer</span>&#123;</div><div class="line">  <span class="comment">//这里的一个声明确保了外部的同名 函数可以访问内部protected资源，也是一种单例的模式</span></div><div class="line">  friend <span class="built_in">Writer</span>* getWriter();</div><div class="line">  protected:</div><div class="line">    <span class="built_in">Writer</span>()&#123;&#125;</div><div class="line">    ~<span class="built_in">Writer</span>()&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="C-Idioms-Execute-Around-Pointer"><a href="#C-Idioms-Execute-Around-Pointer" class="headerlink" title="C++ Idioms/Execute-Around Pointer"></a>C++ Idioms/Execute-Around Pointer</h2><p>有些时候我们需要像python装饰器一样的东西，这个时候Execute-Around Pointer是一个很好的技巧，如下code完成了在每次push_back之前后打印Size</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> VisualizableVector &#123;</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">class</span> proxy &#123;</div><div class="line">      <span class="keyword">public</span>:</div><div class="line">        proxy (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; *v) : vect (v) &#123;</div><div class="line">          <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Before size is: "</span> &lt;&lt; vect-&gt;size ();</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; * <span class="keyword">operator</span> -&gt; () &#123;</div><div class="line">          <span class="keyword">return</span> vect;</div><div class="line">        &#125;</div><div class="line">        ~proxy () &#123;</div><div class="line">          <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"After size is: "</span> &lt;&lt; vect-&gt;size ();</div><div class="line">        &#125;</div><div class="line">      <span class="keyword">private</span>:</div><div class="line">        <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; * vect;</div><div class="line">    &#125;;</div><div class="line">    VisualizableVector (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; *v) : vect(v) &#123;&#125;    </div><div class="line">    proxy <span class="keyword">operator</span> -&gt; () &#123;</div><div class="line">       <span class="keyword">return</span> proxy (vect);</div><div class="line">    &#125;</div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; * vect;</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  <span class="function">VisualizableVector <span class="title">vecc</span> <span class="params">(<span class="keyword">new</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;)</span></span>;</div><div class="line">  <span class="comment">//...</span></div><div class="line">  vecc-&gt;push_back (<span class="number">10</span>); <span class="comment">// Note use of -&gt; operator instead of . operator</span></div><div class="line">  vecc-&gt;push_back (<span class="number">20</span>); <span class="comment">//等同于vecc.operator-&gt;()</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><a href="https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Execute-Around_Pointer" target="_blank" rel="external">C++ Idioms/Execute-Around Pointer</a></li>
<li><a href="http://en.cppreference.com/w/cpp/language/operators" target="_blank" rel="external">operators overload</a></li>
</ul>
<h2 id="Hack-with-LD-PRELOAD"><a href="#Hack-with-LD-PRELOAD" class="headerlink" title="Hack with LD_PRELOAD"></a>Hack with LD_PRELOAD</h2><p>这个可以用来覆盖要load的动态库中的方法或者类什么的，可以做hack，是个hook</p>
<ul>
<li><a href="https://www.exploit-db.com/papers/13233/" target="_blank" rel="external">Reverse Engineering with LD_PRELOAD</a></li>
<li><a href="http://blog.csdn.net/haoel/article/details/1602108" target="_blank" rel="external">利用LD_PRELOAD进行hook</a></li>
</ul>
<h2 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h2><p>Tail call是一个处理递归爆栈的好方案，但是并不是说Tail call就一点栈开销的没有，另外C++有时候虽然使用了Tall call但是并没达到预期效果，因为一些对象的析构可能会影响他，可以采取一些传引用或者传指正的方法处理，不过如果能用循环就别用递归</p>
<h2 id="FILE-线程安全"><a href="#FILE-线程安全" class="headerlink" title="FILE 线程安全"></a>FILE 线程安全</h2><ul>
<li>在同一个进程内, 针对同一个FILE*的操作(比如fwrite), 是线程安全的(Windows不是哦)</li>
<li>As an example, the POSIX standard requires that C stdio FILE<em> operations are atomic. POSIX-conforming C libraries (e.g, on Solaris and GNU/Linux) have an internal mutex to serialize operations on FILE</em>s. However, you still need to not do stupid things like calling fclose(fs) in one thread followed by an access of fs in another.</li>
<li>对于PIPE和FIFO, 只要写入数据不超过PIPE_BUF size那么也是atomic<a href="http://man7.org/linux/man-pages/man7/pipe.7.html" target="_blank" rel="external">PIPE DOC</a>, 但是对于文件：This volume of POSIX.1-2008 does not specify behavior of concurrent writes to a file from multiple processes. Applications should use some form of concurrency control.</li>
<li>O_APPEND<br>  The file is opened in append mode.  Before each write(2), the file offset is positioned at the end of the file, as if with lseek(2).  O_APPEND may lead to corrupted files on NFS filesystems if more than one process appends data to a file at once.  This is because NFS does not support appending to a file, so the client kernel has to simulate it, which can’t be done without a race condition.<br><a href="http://man7.org/linux/man-pages/man2/open.2.html" target="_blank" rel="external">O_APPEND DOC</a></li>
<li>OpenBSD 的代码里 fwrite是有文件锁的。。。</li>
</ul>
<p>有人写了程序验证超过PIPE_BUF会不会乱序，答复是这样的：</p>
<blockquote>
<p>It’s not luck, in the sense that if you dig into the kernel you can probably prove that in your particular circumstances it will never happen that one processes’ write is interleaved with another one. I am assuming that:</p>
<ul>
<li>You are not hitting any file size limits</li>
<li>You are not filling the filesystem in which you create the test file</li>
<li>The file is a regular file (not a socket, pipe, or something else)</li>
<li>The filesystem is local</li>
<li>The buffer does not span multiple virtual memory mappings (this one is known to be true, because it’s malloc()ed, which puts it on the heap, which it contiguous.</li>
<li>The processes aren’t interrupted, signaled, or traced while write() is busy.</li>
<li>There are no disk I/O errors, RAM failures, or any other abnormal conditions.</li>
<li>(Maybe others)<br>You will probably indeed find that if all those assumptions hold, it is the case that the kernel of the operating system you happen to be using always accomplishes a single write() system call with a single atomic contiguous write to the following file.</li>
</ul>
<p>That doesn’t mean you can count on this always being true. You never know when it might not be true when:</p>
<p>the program is run on a different operating system<br>the file moves to an NFS filesystem<br>the process gets a signal while the write() is in progress and the write() returns a partial result (fewer bytes than requested). Not sure if POSIX really allows this to happen but I program defensively!<br>etc…<br>So your experiment can’t prove that you can could on non-interleaved writes.</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://gaoshen.site/2014-9-2-linux-command-note/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Matthew Gao">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Matthew Note">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Matthew Note" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014-9-2-linux-command-note/" itemprop="url">
                  Linux Command Notes
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2014-9-2-linux-command-note/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014-9-2-linux-command-note/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          
              <div class="post-description">
                  学习笔记：记录下Linux使用中不断遇到的命令
              </div>
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="stat"><a href="#stat" class="headerlink" title="stat"></a>stat</h2><p>可以用stat命令，查看某个文件的inode信息</p>
<h2 id="mount"><a href="#mount" class="headerlink" title="mount"></a>mount</h2><h3 id="mount-a-dir"><a href="#mount-a-dir" class="headerlink" title="mount a dir"></a>mount a dir</h3><ul>
<li>-t 指定文件系统类型，通常可以不指定，除了一些特殊的比如, smbfs, tmpfs, proc, sysfs等等</li>
<li>-bind 通常来讲mount是mount一个设备到文件目录，但是同样可以使用bind来mount一个目录到另一个目录</li>
<li>-o 代表 option，<figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mount -o <span class="keyword">bind</span></div><div class="line">mount -<span class="keyword">bind</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="mount一个网络共享文件夹"><a href="#mount一个网络共享文件夹" class="headerlink" title="mount一个网络共享文件夹"></a>mount一个网络共享文件夹</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mount <span class="regexp">//</span><span class="number">10.103</span>.<span class="number">226.143</span><span class="regexp">/abc /m</span>nt<span class="regexp">/net</span></div></pre></td></tr></table></figure>
<p>这个对Ubuntu和Mint有效，有些情况下可能需要指定文件系统格式</p>
<blockquote>
<p><code>-t smbfs -o username=root, password=pass</code></p>
</blockquote>
<h3 id="umount-a-busy-device"><a href="#umount-a-busy-device" class="headerlink" title="umount a busy device"></a>umount a busy device</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">umount <span class="_">-l</span> unpacked/rbe</div></pre></td></tr></table></figure>
<blockquote>
<p>-l 代表lazy，可以强制umount一个device，如果依旧不行，可以尝试用 </p>
</blockquote>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">lsof | grep unpacked/rbe<span class="comment"></span></div><div class="line">//或者</div><div class="line">fuser <span class="keyword">a</span> <span class="built_in">file</span></div></pre></td></tr></table></figure>
<blockquote>
<p>来查找具体是谁占用了，Kill他</p>
</blockquote>
<h2 id="skip-an-existed-dir"><a href="#skip-an-existed-dir" class="headerlink" title="skip an existed dir"></a>skip an existed dir</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mkdir -<span class="selector-tag">p</span> dir1</div></pre></td></tr></table></figure>
<h2 id="Create-a-link"><a href="#Create-a-link" class="headerlink" title="Create a link"></a>Create a link</h2><figure class="highlight excel"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">ln</span> file1 file2</div><div class="line"><span class="built_in">ln</span> -s file1 file2</div></pre></td></tr></table></figure>
<blockquote>
<p>hard link and soft link</p>
</blockquote>
<h2 id="X-windows"><a href="#X-windows" class="headerlink" title="X windows"></a>X windows</h2><p>X Windows包含几个部分:</p>
<ul>
<li>X server, 主要用于和硬件打交道，把绘图展示到显示器上</li>
<li>X client，关注与如何绘图，和绘制什么样的图形，一个完全抽象出来的脱离硬件的层面</li>
<li>Display manager, 用来管理多个Xclient绘制的窗口，最常见的有gdm，lightdm，sddm(kde), twm，i3block等</li>
</ul>
<h3 id="调整分辨率"><a href="#调整分辨率" class="headerlink" title="调整分辨率"></a>调整分辨率</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">xrandr <span class="_">-l</span></div><div class="line">xrandr <span class="_">-s</span> 1280x960</div></pre></td></tr></table></figure>
<blockquote>
<p>分辨率需要驱动支持，如果不支持会报错。 对于VBOX和VM，需要先安装VBOX tools和vmware-tools<br>有些时候需要更改显示驱动，在Xorg.conf中，虚拟机和服务器大多默认vesa</p>
</blockquote>
<h2 id="Console-Terminal"><a href="#Console-Terminal" class="headerlink" title="Console/Terminal"></a>Console/Terminal</h2><p>这是两个很容易混淆的概念，Console通常指的是一个串行借口，Terminal通常指的是一个Bash, Console通常会启动一个Bash</p>
<ul>
<li>Console分为两种，ttyX和ttySX, 前者是一个逻辑上的Console，后者是物理上的Serial Console，Console的相关设置，可以在Grub这类工具中设置，Linux中通常是使用tty了，如果你有个COM口，那么可以用ttyS</li>
<li>系统在启动的时候inittab中会设置，通过getty来获得一个console</li>
<li>Text Console的分辨率就不能用xrandr了，可以在grub中通过vga=ask/ID来设置，具体ID取决于硬件支持</li>
<li>stty可以设置tty相关属性，比如对应快捷键</li>
</ul>
<h2 id="权限操作"><a href="#权限操作" class="headerlink" title="权限操作"></a>权限操作</h2><ul>
<li>adduser</li>
<li>addgroup 加user到group</li>
<li>groupadd 新建一个group</li>
<li>usermod 可以改变user的属性，比如属于哪个Group，注意group改完要重新gdm进去才能生效</li>
</ul>
<h3 id="SElinux"><a href="#SElinux" class="headerlink" title="SElinux"></a>SElinux</h3><p>是一个更高级的权限管理，可以避免一个有很高权限的程序随意访问文件系统，比如httpd，一个普通用户可以操作httpd来访问root权限的目录</p>
<h2 id="DNS-lookup"><a href="#DNS-lookup" class="headerlink" title="DNS lookup"></a>DNS lookup</h2><figure class="highlight dns"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">sslvpn:~# host -a baidu.com</div><div class="line"></div><div class="line">Trying "baidu.com"</div><div class="line"><span class="comment">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 53987</span></div><div class="line"><span class="comment">;; flags: qr rd ra; QUERY: 1, ANSWER: 14, AUTHORITY: 0, ADDITIONAL: 7</span></div><div class="line"></div><div class="line"><span class="comment">;; QUESTION SECTION:</span></div><div class="line"><span class="comment">;baidu.com.                     IN      ANY</span></div><div class="line"></div><div class="line"><span class="comment">;; ANSWER SECTION:</span></div><div class="line">baidu.com.              <span class="number">462</span>     <span class="keyword">IN</span>      <span class="keyword">A</span>       <span class="number">123.125.114.144</span></div><div class="line">baidu.com.              <span class="number">462</span>     <span class="keyword">IN</span>      <span class="keyword">A</span>       <span class="number">220.181.111.85</span></div><div class="line">baidu.com.              <span class="number">462</span>     <span class="keyword">IN</span>      <span class="keyword">A</span>       <span class="number">220.181.111.86</span></div><div class="line">baidu.com.              <span class="number">86262</span>   <span class="keyword">IN</span>      <span class="keyword">NS</span>      ns4.baidu.com.</div><div class="line">baidu.com.              <span class="number">86262</span>   <span class="keyword">IN</span>      <span class="keyword">NS</span>      dns.baidu.com.</div><div class="line">baidu.com.              <span class="number">86262</span>   <span class="keyword">IN</span>      <span class="keyword">NS</span>      ns3.baidu.com.</div><div class="line">baidu.com.              <span class="number">86262</span>   <span class="keyword">IN</span>      <span class="keyword">NS</span>      ns2.baidu.com.</div><div class="line">baidu.com.              <span class="number">86262</span>   <span class="keyword">IN</span>      <span class="keyword">NS</span>      ns7.baidu.com.</div><div class="line">baidu.com.              <span class="number">7062</span>    <span class="keyword">IN</span>      <span class="keyword">SOA</span>     dns.baidu.com. sa.baidu.com. <span class="number">2012120775</span> <span class="number">300 300</span> <span class="number">2592000</span> <span class="number">7200</span></div><div class="line">baidu.com.              <span class="number">7062</span>    <span class="keyword">IN</span>      <span class="keyword">MX</span>      <span class="number">20</span> mx1.baidu.com.</div><div class="line">baidu.com.              <span class="number">7062</span>    <span class="keyword">IN</span>      <span class="keyword">MX</span>      <span class="number">20</span> jpmx.baidu.com.</div><div class="line">baidu.com.              <span class="number">7062</span>    <span class="keyword">IN</span>      <span class="keyword">MX</span>      <span class="number">20</span> mx50.baidu.com.</div><div class="line">baidu.com.              <span class="number">7062</span>    <span class="keyword">IN</span>      <span class="keyword">MX</span>      <span class="number">10</span> mx.n.shifen.com.</div><div class="line">baidu.com.              <span class="number">7062</span>    <span class="keyword">IN</span>      <span class="keyword">TXT</span>     "v=spf1 include:spf1.baidu.com include:spf2.baidu.com include:spf3.baidu.com a mx ptr ~all"</div><div class="line"></div><div class="line"><span class="comment">;; ADDITIONAL SECTION:</span></div><div class="line">ns4.baidu.com.          <span class="number">86262</span>   <span class="keyword">IN</span>      <span class="keyword">A</span>       <span class="number">220.181.38.10</span></div><div class="line">dns.baidu.com.          <span class="number">86262</span>   <span class="keyword">IN</span>      <span class="keyword">A</span>       <span class="number">202.108.22.220</span></div><div class="line">ns3.baidu.com.          <span class="number">86262</span>   <span class="keyword">IN</span>      <span class="keyword">A</span>       <span class="number">220.181.37.10</span></div><div class="line">ns2.baidu.com.          <span class="number">86262</span>   <span class="keyword">IN</span>      <span class="keyword">A</span>       <span class="number">61.135.165.235</span></div><div class="line">ns7.baidu.com.          <span class="number">86085</span>   <span class="keyword">IN</span>      <span class="keyword">A</span>       <span class="number">119.75.219.82</span></div><div class="line">mx1.baidu.com.          <span class="number">162</span>     <span class="keyword">IN</span>      <span class="keyword">A</span>       <span class="number">61.135.163.61</span></div><div class="line">jpmx.baidu.com.         <span class="number">7062</span>    <span class="keyword">IN</span>      <span class="keyword">A</span>       <span class="number">61.208.132.13</span></div><div class="line"></div><div class="line">Received <span class="number">508</span> bytes from <span class="number">10.8.85.239</span>#<span class="number">53</span> in <span class="number">218</span> ms</div></pre></td></tr></table></figure>
<h2 id="man"><a href="#man" class="headerlink" title="man"></a>man</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">man --regex ‘convert’</div><div class="line">--Man-- nex<span class="variable">t:</span> gsettings-schema-convert(<span class="number">1</span>) [ <span class="keyword">view</span> (<span class="keyword">return</span>) | skip (Ctrl-D) | <span class="keyword">quit</span> (Ctrl-C) ]</div><div class="line">--Man-- nex<span class="variable">t:</span> tapconvert(<span class="number">1</span>) [ <span class="keyword">view</span> (<span class="keyword">return</span>) | skip (Ctrl-D) | <span class="keyword">quit</span> (Ctrl-C) ]</div><div class="line">--Man-- nex<span class="variable">t:</span> <span class="number">2</span>to3(<span class="number">1</span>) [ <span class="keyword">view</span> (<span class="keyword">return</span>) | skip (Ctrl-D) | <span class="keyword">quit</span> (Ctrl-C) ]</div><div class="line">--Man-- nex<span class="variable">t:</span> <span class="number">2</span>to3-<span class="number">3.2</span>(<span class="number">1</span>) [ <span class="keyword">view</span> (<span class="keyword">return</span>) | skip (Ctrl-D) | <span class="keyword">quit</span> (Ctrl-C) ]</div><div class="line">--Man-- nex<span class="variable">t:</span> addr2line(<span class="number">1</span>) [ <span class="keyword">view</span> (<span class="keyword">return</span>) | skip (Ctrl-D) | <span class="keyword">quit</span> (Ctrl-C) ]</div><div class="line">--Man-- nex<span class="variable">t:</span> atobm(<span class="number">1</span>) [ <span class="keyword">view</span> (<span class="keyword">return</span>) | skip (Ctrl-D) | <span class="keyword">quit</span> (Ctrl-C) ]</div><div class="line">--Man-- nex<span class="variable">t:</span> b2m(<span class="number">1</span>) [ <span class="keyword">view</span> (<span class="keyword">return</span>) | skip (Ctrl-D) | <span class="keyword">quit</span> (Ctrl-C) ]</div><div class="line">--Man-- nex<span class="variable">t:</span> bdftopcf(<span class="number">1</span>) [ <span class="keyword">view</span> (<span class="keyword">return</span>) | skip (Ctrl-D) | <span class="keyword">quit</span> (Ctrl-C) ]</div></pre></td></tr></table></figure>
<p>查看所有convert相关的手册</p>
<h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">source</span> <span class="regexp">/root/</span>.bashrc</div></pre></td></tr></table></figure>
<h2 id="查看程序依赖关系"><a href="#查看程序依赖关系" class="headerlink" title="查看程序依赖关系"></a>查看程序依赖关系</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">ldd /usr/bin/openssl</div><div class="line">	linux-vdso.so<span class="number">.1</span> =&gt;  (<span class="number">0x00007fffcd05c000</span>)</div><div class="line">	libssl.so<span class="number">.1</span><span class="number">.0</span><span class="number">.0</span> =&gt; /tip/bldfs/usr/lib/libssl.so<span class="number">.1</span><span class="number">.0</span><span class="number">.0</span> (<span class="number">0x00007fe45fb99000</span>)</div><div class="line">	libcrypto.so<span class="number">.1</span><span class="number">.0</span><span class="number">.0</span> =&gt; /tip/bldfs/usr/lib/libcrypto.so<span class="number">.1</span><span class="number">.0</span><span class="number">.0</span> (<span class="number">0x00007fe45f7b1000</span>)</div><div class="line">	libdl.so<span class="number">.2</span> =&gt; /lib/x86_64-linux-gnu/libdl.so<span class="number">.2</span> (<span class="number">0x00007fe45f5aa000</span>)</div><div class="line">	libz.so<span class="number">.1</span> =&gt; /tip/bldfs/usr/lib/libz.so<span class="number">.1</span> (<span class="number">0x00007fe45f394000</span>)</div><div class="line">	libc.so<span class="number">.6</span> =&gt; /lib/x86_64-linux-gnu/libc.so<span class="number">.6</span> (<span class="number">0x00007fe45f009000</span>)</div><div class="line">	/lib64/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span> (<span class="number">0x00007fe45fe07000</span>)</div></pre></td></tr></table></figure>
<blockquote>
<p>nm</p>
</blockquote>
<h2 id="查看库文件导出symbol"><a href="#查看库文件导出symbol" class="headerlink" title="查看库文件导出symbol"></a>查看库文件导出symbol</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">objdump -T /usr/lib/libcrypto.so<span class="number">.1</span><span class="number">.0</span><span class="number">.0</span>| grep EVP_rc4</div><div class="line"><span class="number">00000000000</span>fbe20 g    DF .text	<span class="number">0000000000000008</span>  OPENSSL_1<span class="number">.0</span><span class="number">.0</span> EVP_rc4</div><div class="line"><span class="number">00000000001086e0</span> g    DF .text	<span class="number">0000000000000008</span>  OPENSSL_1<span class="number">.0</span><span class="number">.1</span> EVP_rc4_hmac_md5</div><div class="line"><span class="number">00000000000</span>fbe30 g    DF .text	<span class="number">0000000000000008</span>  OPENSSL_1<span class="number">.0</span><span class="number">.0</span> EVP_rc4_40</div></pre></td></tr></table></figure>
<h2 id="RBE编译问题"><a href="#RBE编译问题" class="headerlink" title="RBE编译问题"></a>RBE编译问题</h2><figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attr">LD_LIBRARY_PATH</span>=/usr/lib/x<span class="number">86_64</span>-linux-gnu/:<span class="variable">$LD_LIBRARY_PATH</span></div></pre></td></tr></table></figure>
<p>由于有两个<code>libcrypto.so.1.0.0</code>，分别在<code>/tip/bldfs/usr/lib/</code>里和<code>/usr/lib/x86_64-linux-gnu</code>, 两个版本不同 一个为1.0.0 一个为1.0.1 所以在使用ssl相关工具， 比如ssh，rsync时候会显示找不到symbol，这时需要手动设置<code>LD_LIBRARY_PATH</code></p>
<ul>
<li>LIBRARY_PATH is used by gcc before compilation to search for directories containing libraries that need to be linked to your program.</li>
<li>LD_LIBRARY_PATH is used by your program to search for directories containing the libraries after it has been successfully compiled and linked.</li>
</ul>
<h2 id="程序栈最大大小"><a href="#程序栈最大大小" class="headerlink" title="程序栈最大大小"></a>程序栈最大大小</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">ulimit</span> <span class="_">-s</span></div></pre></td></tr></table></figure>
<h2 id="查看每个目录硬盘占的空间"><a href="#查看每个目录硬盘占的空间" class="headerlink" title="查看每个目录硬盘占的空间"></a>查看每个目录硬盘占的空间</h2><figure class="highlight 1c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">du -sm</div><div class="line">df -ah <span class="comment">//查看各个盘空间</span></div><div class="line">fdiks -l</div></pre></td></tr></table></figure>
<h2 id="作业控制"><a href="#作业控制" class="headerlink" title="作业控制"></a>作业控制</h2><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta-keyword">/usr/</span>bin/policyserver&amp;</div><div class="line"></div><div class="line">(kili64-rbe)shgao-virtual-machine:<span class="meta-keyword">/tip/</span>src<span class="meta-keyword">/avt/</span>gentoo<span class="meta"># jobs</span></div><div class="line">[<span class="number">1</span>]+  Stopped                 <span class="meta-keyword">/usr/</span>local<span class="meta-keyword">/extranet/</span>bin/policyserver -f --logserverport <span class="number">0</span></div><div class="line">(kili64-rbe)shgao-virtual-machine:<span class="meta-keyword">/tip/</span>src<span class="meta-keyword">/avt/</span>gentoo<span class="meta"># bg 1</span></div><div class="line">[<span class="number">1</span>]+ <span class="meta-keyword">/usr/</span>local<span class="meta-keyword">/extranet/</span>bin/policyserver -f --logserverport <span class="number">0</span> &amp;</div><div class="line">(kili64-rbe)shgao-virtual-machine:<span class="meta-keyword">/tip/</span>src<span class="meta-keyword">/avt/</span>gentoo<span class="meta"># jobs</span></div><div class="line">[<span class="number">1</span>]+  Running                 <span class="meta-keyword">/usr/</span>local<span class="meta-keyword">/extranet/</span>bin/policyserver -f --logserverport <span class="number">0</span> &amp;</div><div class="line">(kili64-rbe)shgao-virtual-machine:<span class="meta-keyword">/tip/</span>src<span class="meta-keyword">/avt/</span>gentoo<span class="meta">#</span></div></pre></td></tr></table></figure>
<ul>
<li><code>ctrl+z</code> 暂停并放到后台</li>
<li>程序后面加上&amp;，使之自动在后台运行</li>
<li><code>bg</code> 将一个在后台暂停的命令，变成继续执行</li>
<li><code>fg</code> 将后台中的命令调至前台继续运行</li>
<li><code>kill %num</code> num不是PID</li>
</ul>
<h2 id="ldconfig"><a href="#ldconfig" class="headerlink" title="ldconfig"></a>ldconfig</h2><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">ldconfig -v</span></div></pre></td></tr></table></figure>
<p><code>ldconfig</code>是一个动态链接库管理命令，为了让动态链接库为系统所共享,还需运行动态链接 库的管理命令<code>--ldconfig ldconfig</code> 命令的用途,主要是在默认搜寻目录(<code>/lib</code>和<code>/usr/lib</code>)以及动态库配置文件<code>/etc/ld.so.conf</code>内所列的目录下,搜索出可共享的动态 链接库(格式如前介绍,<code>lib*.so*</code>),进而创建出动态装入程序(<code>ld.so</code>)所需的连接和缓存文件.缓存文件默认为 <code>/etc/ld.so.cache</code>,此文件保存已排好序的动态链接库名字列表. 他的存在是为了程序可以更快的load相关的lib，相当于一个cache</p>
<h2 id="chkconfig"><a href="#chkconfig" class="headerlink" title="chkconfig"></a>chkconfig</h2><figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">shgao<span class="variable">@shgao</span>-virtual-<span class="symbol">machine:</span>~<span class="regexp">/workplace/</span>Firmware/EXSeriesVPN<span class="variable">$ </span>chkconfig --list</div><div class="line">acpi-support              <span class="number">0</span><span class="symbol">:off</span>  <span class="number">1</span><span class="symbol">:off</span>  <span class="number">2</span><span class="symbol">:on</span>   <span class="number">3</span><span class="symbol">:on</span>   <span class="number">4</span><span class="symbol">:on</span>   <span class="number">5</span><span class="symbol">:on</span>   <span class="number">6</span><span class="symbol">:off</span></div><div class="line">acpid                     <span class="number">0</span><span class="symbol">:off</span>  <span class="number">1</span><span class="symbol">:off</span>  <span class="number">2</span><span class="symbol">:off</span>  <span class="number">3</span><span class="symbol">:off</span>  <span class="number">4</span><span class="symbol">:off</span>  <span class="number">5</span><span class="symbol">:off</span>  <span class="number">6</span><span class="symbol">:off</span></div><div class="line">alsa-restore              <span class="number">0</span><span class="symbol">:off</span>  <span class="number">1</span><span class="symbol">:off</span>  <span class="number">2</span><span class="symbol">:off</span>  <span class="number">3</span><span class="symbol">:off</span>  <span class="number">4</span><span class="symbol">:off</span>  <span class="number">5</span><span class="symbol">:off</span>  <span class="number">6</span><span class="symbol">:off</span></div><div class="line">alsa-store                <span class="number">0</span><span class="symbol">:off</span>  <span class="number">1</span><span class="symbol">:off</span>  <span class="number">2</span><span class="symbol">:off</span>  <span class="number">3</span><span class="symbol">:off</span>  <span class="number">4</span><span class="symbol">:off</span>  <span class="number">5</span><span class="symbol">:off</span>  <span class="number">6</span><span class="symbol">:off</span></div><div class="line">anacron                   <span class="number">0</span><span class="symbol">:off</span>  <span class="number">1</span><span class="symbol">:off</span>  <span class="number">2</span><span class="symbol">:off</span>  <span class="number">3</span><span class="symbol">:off</span>  <span class="number">4</span><span class="symbol">:off</span>  <span class="number">5</span><span class="symbol">:off</span>  <span class="number">6</span><span class="symbol">:off</span></div><div class="line">apparmor                  <span class="number">0</span><span class="symbol">:off</span>  <span class="number">1</span><span class="symbol">:off</span>  <span class="number">2</span><span class="symbol">:off</span>  <span class="number">3</span><span class="symbol">:off</span>  <span class="number">4</span><span class="symbol">:off</span>  <span class="number">5</span><span class="symbol">:off</span>  <span class="number">6</span><span class="symbol">:off</span>  <span class="symbol">S:</span>on</div></pre></td></tr></table></figure>
<ul>
<li>–add   新增所指定的系统服务</li>
<li>–del 删除所指定的系统服务</li>
<li>–level 指定该系统服务要在哪个执行等级中开启或关闭</li>
<li>–list   列出当前可从<code>chkconfig</code>指令管理的所有系统服务和等级代号</li>
<li>on/off/reset   在指定的执行登记,开启/关闭/重置该系统服务</li>
</ul>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><ul>
<li><code>+</code>表示重复一次或多次</li>
<li><code>[]</code> 中的字符不需要转义，就表示本义</li>
<li><code>?:</code> 告诉引擎匹配前导字符0次或一次。事实上是表示前导字符是可选的。 </li>
<li><code>+:</code> 告诉引擎匹配前导字符1次或多次 </li>
<li><code>*:</code> 告诉引擎匹配前导字符0次或多次</li>
<li><code>{}:</code> 表示前导字符重复的次数</li>
<li><code>():</code> 组（向后引用）</li>
<li><code>.</code> 匹配任意字符（除了\n）</li>
<li><code>\b</code> 匹配单词边界</li>
<li><code>\B</code> 匹配非单词边界</li>
<li><code>|</code> 与 <code>cat|dog</code>，与<code>[]</code>相似，但是<code>[]</code>只能匹配一个字符</li>
<li><code>\w</code> 匹配一个单词</li>
<li><code>\W</code> 匹配任何非单词的字符</li>
<li><code>(?&gt;正则表达式)</code> ：阻止海量回溯</li>
<li>正则表达式具有贪婪性，可以用在<code>?,+,*,{}</code>之后加一个?来实现这一点，或者靠取反：<code>&lt;[^&gt;]+&gt;</code></li>
<li>在字符集<code>[]</code>中， 除了<code>]\^-</code>需要转义，其他都不用转义，当然转义也不会错</li>
</ul>
<p>向后引用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">grep -E  <span class="string">'(\w)\1'</span> /var/<span class="built_in">log</span>/<span class="built_in">test</span> </div><div class="line">3 rrrr</div><div class="line">135 nnn</div></pre></td></tr></table></figure>
<h3 id="Grep"><a href="#Grep" class="headerlink" title="Grep"></a>Grep</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">grep</span> -En <span class="string">"\-j"</span> Makefile</div><div class="line"><span class="keyword">grep</span> -En <span class="string">'\-j'</span> Makefile</div><div class="line"></div><div class="line"><span class="keyword">grep</span> -Ev <span class="string">' ps [0-9a-z]* Debug 3 '</span> ap_ps.<span class="built_in">log</span> &gt; ap_ps_rip_debug3.<span class="built_in">log</span></div></pre></td></tr></table></figure>
<ul>
<li>双引号会先解析其中的变量和命令</li>
<li>单引号是原样匹配</li>
<li>\ 转义，不要记错…</li>
<li>-A 5 向后5行</li>
<li>-B 5 向前5行</li>
<li>-C 5 前后各5行</li>
<li>-H 显示文件名</li>
<li><code>-v</code> 取反</li>
</ul>
<h3 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">awk -F' ' '<span class="variable">$5</span>=<span class="string">"ap"</span> &#123;<span class="keyword">print</span> NR <span class="string">":"</span> $(NF) &#125;' /<span class="keyword">var</span>/<span class="keyword">log</span>/aventail/access_servers.<span class="built_in">log</span></div><div class="line">awk '&#123;<span class="keyword">if</span>(NF&gt;=6)&#123;<span class="keyword">for</span> (i=5;i&lt;=NF;i++)printf(<span class="string">"%s "</span>, <span class="variable">$i</span>);printf <span class="string">"\n"</span>&#125;&#125;' tmp.<span class="keyword">log</span> <span class="comment">//输出第六列之后所有列</span></div></pre></td></tr></table></figure>
<ul>
<li>-F 表示分隔符</li>
<li>$5 表示第五个</li>
<li>NR 表示行号，内嵌</li>
<li>NF 表示每行有几个分割域</li>
</ul>
<h3 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h3><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed ‘s/^<span class="string">[A-Z]</span>*/replace/g’</div></pre></td></tr></table></figure>
<ul>
<li>g 表示global</li>
</ul>
<h2 id="strace"><a href="#strace" class="headerlink" title="strace"></a>strace</h2><p>记录命令的系统调用，例如</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">#strace echo “abc”</div><div class="line">execve(<span class="string">"/bin/echo"</span>, [<span class="string">"echo"</span>, <span class="string">"aa"</span>], [<span class="comment">/* 36 vars */</span>]) = <span class="number">0</span></div><div class="line">brk(<span class="number">0</span>)                                  = <span class="number">0x882000</span></div><div class="line">access(<span class="string">"/etc/ld.so.nohwcap"</span>, F_OK)      = <span class="number">-1</span> ENOENT (No such file or directory)</div><div class="line">mmap(NULL, <span class="number">8192</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>) = <span class="number">0x7f2ca3275000</span></div><div class="line">access(<span class="string">"/etc/ld.so.preload"</span>, R_OK)      = <span class="number">-1</span> ENOENT (No such file or directory)</div><div class="line">open(<span class="string">"/etc/ld.so.cache"</span>, O_RDONLY|O_CLOEXEC) = <span class="number">3</span></div><div class="line">fstat(<span class="number">3</span>, &#123;st_mode=S_IFREG|<span class="number">0644</span>, st_size=<span class="number">66284</span>, ...&#125;) = <span class="number">0</span></div><div class="line">mmap(NULL, <span class="number">66284</span>, PROT_READ, MAP_PRIVATE, <span class="number">3</span>, <span class="number">0</span>) = <span class="number">0x7f2ca3264000</span></div><div class="line">close(<span class="number">3</span>)                                = <span class="number">0</span></div><div class="line">access(<span class="string">"/etc/ld.so.nohwcap"</span>, F_OK)      = <span class="number">-1</span> ENOENT (No such file or directory)</div><div class="line">open(<span class="string">"/lib/x86_64-linux-gnu/libc.so.6"</span>, O_RDONLY|O_CLOEXEC) = <span class="number">3</span></div><div class="line">read(<span class="number">3</span>, <span class="string">"\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0\200\30\2\0\0\0\0\0"</span>..., <span class="number">832</span>) = <span class="number">832</span></div><div class="line">fstat(<span class="number">3</span>, &#123;st_mode=S_IFREG|<span class="number">0755</span>, st_size=<span class="number">1811128</span>, ...&#125;) = <span class="number">0</span></div><div class="line">mmap(NULL, <span class="number">3925208</span>, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, <span class="number">3</span>, <span class="number">0</span>) = <span class="number">0x7f2ca2c96000</span></div><div class="line">mprotect(<span class="number">0x7f2ca2e4b000</span>, <span class="number">2093056</span>, PROT_NONE) = <span class="number">0</span></div><div class="line">mmap(<span class="number">0x7f2ca304a000</span>, <span class="number">24576</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, <span class="number">3</span>, <span class="number">0x1b4000</span>) = <span class="number">0x7f2ca304a000</span></div><div class="line">mmap(<span class="number">0x7f2ca3050000</span>, <span class="number">17624</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>) = <span class="number">0x7f2ca3050000</span></div><div class="line">close(<span class="number">3</span>)                                = <span class="number">0</span></div><div class="line">mmap(NULL, <span class="number">4096</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>) = <span class="number">0x7f2ca3263000</span></div><div class="line">mmap(NULL, <span class="number">4096</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>) = <span class="number">0x7f2ca3262000</span></div><div class="line">mmap(NULL, <span class="number">4096</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>) = <span class="number">0x7f2ca3261000</span></div><div class="line">arch_prctl(ARCH_SET_FS, <span class="number">0x7f2ca3262700</span>) = <span class="number">0</span></div><div class="line">mprotect(<span class="number">0x7f2ca304a000</span>, <span class="number">16384</span>, PROT_READ) = <span class="number">0</span></div><div class="line">mprotect(<span class="number">0x605000</span>, <span class="number">4096</span>, PROT_READ)     = <span class="number">0</span></div><div class="line">mprotect(<span class="number">0x7f2ca3277000</span>, <span class="number">4096</span>, PROT_READ) = <span class="number">0</span></div><div class="line">munmap(<span class="number">0x7f2ca3264000</span>, <span class="number">66284</span>)           = <span class="number">0</span></div><div class="line">brk(<span class="number">0</span>)                                  = <span class="number">0x882000</span></div><div class="line">brk(<span class="number">0x8a3000</span>)                           = <span class="number">0x8a3000</span></div><div class="line">open(<span class="string">"/usr/lib/locale/locale-archive"</span>, O_RDONLY|O_CLOEXEC) = <span class="number">3</span></div><div class="line">fstat(<span class="number">3</span>, &#123;st_mode=S_IFREG|<span class="number">0644</span>, st_size=<span class="number">7220736</span>, ...&#125;) = <span class="number">0</span></div><div class="line">mmap(NULL, <span class="number">7220736</span>, PROT_READ, MAP_PRIVATE, <span class="number">3</span>, <span class="number">0</span>) = <span class="number">0x7f2ca25b3000</span></div><div class="line">close(<span class="number">3</span>)                                = <span class="number">0</span></div><div class="line">fstat(<span class="number">1</span>, &#123;st_mode=S_IFCHR|<span class="number">0620</span>, st_rdev=makedev(<span class="number">136</span>, <span class="number">6</span>), ...&#125;) = <span class="number">0</span></div><div class="line">mmap(NULL, <span class="number">4096</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>) = <span class="number">0x7f2ca3274000</span></div><div class="line">write(<span class="number">1</span>, <span class="string">"aa<span class="subst">\n</span>"</span>, <span class="number">3</span>aa</div><div class="line">)                     = <span class="number">3</span></div><div class="line">close(<span class="number">1</span>)                                = <span class="number">0</span></div><div class="line">munmap(<span class="number">0x7f2ca3274000</span>, <span class="number">4096</span>)            = <span class="number">0</span></div><div class="line">close(<span class="number">2</span>)                                = <span class="number">0</span></div><div class="line">exit_group(<span class="number">0</span>)                           = ?</div></pre></td></tr></table></figure>
<h2 id="各种重定向"><a href="#各种重定向" class="headerlink" title="各种重定向"></a>各种重定向</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">xmlread <span class="regexp">/home/</span>xxx<span class="regexp">/abc/</span>xml <span class="number">2</span>&gt;&amp;<span class="number">1</span></div><div class="line"></div><div class="line"><span class="keyword">find</span> . -type d -depth <span class="number">1</span> | xargs -I % tar cvzf %.tar.gz %</div><div class="line"></div><div class="line">tar cvf - <span class="regexp">/dir | tar xvf - -C /</span>somewhere</div><div class="line"></div><div class="line">cat &gt; new_file &lt;&lt; fuckend</div><div class="line"><span class="keyword">write</span> something</div><div class="line">blabla</div><div class="line">fuckend</div></pre></td></tr></table></figure>
<h2 id="update-alternatives"><a href="#update-alternatives" class="headerlink" title="update-alternatives"></a>update-alternatives</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">root@shgao-virtual-machine:~# <span class="keyword">update</span>-alternatives  --config nc</div><div class="line">There are <span class="number">2</span> choices <span class="keyword">for</span> the alternative nc (providing /bin/nc).</div><div class="line"></div><div class="line">  Selection    Path                 Priority   Status</div><div class="line">------------------------------------------------------------</div><div class="line">* <span class="number">0</span>            /bin/nc.openbsd       <span class="number">50</span>        auto <span class="keyword">mode</span></div><div class="line">  <span class="number">1</span>            /bin/nc.openbsd       <span class="number">50</span>        manual <span class="keyword">mode</span></div><div class="line">  <span class="number">2</span>            /bin/nc.traditional   <span class="number">10</span>        manual <span class="keyword">mode</span></div><div class="line"></div><div class="line">Press enter <span class="keyword">to</span> keep the current choice[*], <span class="built_in">or</span> <span class="built_in">type</span> selection <span class="keyword">number</span>: <span class="number">2</span></div><div class="line"><span class="keyword">update</span>-alternative<span class="variable">s:</span> using /bin/nc.traditional <span class="keyword">to</span> provide /bin/nc (nc) in manual <span class="keyword">mode</span>.</div></pre></td></tr></table></figure>
<h2 id="Network-Tools"><a href="#Network-Tools" class="headerlink" title="Network Tools"></a>Network Tools</h2><ul>
<li>netcat</li>
<li>curl</li>
<li>wget</li>
<li>ngrep</li>
</ul>
<h2 id="解决windows下编辑文件结尾有-M问题"><a href="#解决windows下编辑文件结尾有-M问题" class="headerlink" title="解决windows下编辑文件结尾有^M问题"></a>解决windows下编辑文件结尾有^M问题</h2><p><code>^M</code> 实际上就是<code>\r</code>, 如果键盘输入要用<code>C-v</code>，<code>C-m</code>来输入</p>
<ul>
<li>解决方法一：安装一个dos2unix，可以转换文本</li>
<li>解决方法二：source insight 中Preference-&gt;Files设置文件结尾    </li>
</ul>
<h2 id="Grub-rescue"><a href="#Grub-rescue" class="headerlink" title="Grub rescue"></a>Grub rescue</h2><figure class="highlight gams"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">grub rescue&gt;<span class="keyword">set</span> root=(hd1,msdos1)</div><div class="line">grub <span class="comment">rescue&gt;set prefix=(hd1,msdos1)</span>/boot/<span class="comment">grub</span></div><div class="line">grub <span class="comment">rescue&gt;insmod</span> /boot/<span class="comment">grub</span>/i386-pc/<span class="comment">normal.mod</span></div><div class="line">grub <span class="comment">rescue&gt;normal</span></div><div class="line"><span class="comment">//之后进入了grub&gt;</span></div><div class="line">grub&gt;linux /boot/<span class="comment">bzImage</span> //加载<span class="comment">linux kernel</span></div><div class="line">grub&gt;initrd /boot/<span class="comment">initrd.gz</span> //加载启动</div><div class="line">grub&gt;boot</div></pre></td></tr></table></figure>
<ul>
<li>grub vga=ask/ID 可以设置text terminal分辨率</li>
</ul>
<h2 id="重新创建xorg-conf"><a href="#重新创建xorg-conf" class="headerlink" title="重新创建xorg.conf"></a>重新创建xorg.conf</h2><p>有些时候xorg.conf的配置会别改坏，用如下方法可以生成一个新的xorg.conf</p>
<p>1.switch to console mode: Alt+Ctrl+F1</p>
<p>2.kill x server: sudo service lightdm stop</p>
<p>3.generate new xorg.conf file: sudo X -configure – this will create xorg.conf.new file in your current dir</p>
<p>4.rename and move: sudo mv xorg.conf.new /etc/X11/xorg.conf</p>
<p>5.return to GUI: sudo start lightdm</p>
<h2 id="vnc4server"><a href="#vnc4server" class="headerlink" title="vnc4server"></a>vnc4server</h2><figure class="highlight vala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta"># vnc4server :1 //启动一个vnc display</span></div><div class="line"><span class="meta"># vnc4server -kill :1</span></div></pre></td></tr></table></figure>
<h2 id="查看硬件状态"><a href="#查看硬件状态" class="headerlink" title="查看硬件状态"></a>查看硬件状态</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">lscpu</div><div class="line">lshw -C <span class="built_in">display</span> <span class="comment">//查看显卡</span></div></pre></td></tr></table></figure>
<h2 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ifconfig eth0 <span class="number">10.103</span><span class="number">.250</span><span class="number">.11</span> netmask <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></div><div class="line">route add <span class="section">default</span> gw <span class="number">10.103</span><span class="number">.250</span><span class="number">.1</span></div></pre></td></tr></table></figure>
<ul>
<li>DNS 配置在 <code>/etc/resolv.conf</code></li>
<li><code>/etc/hosts</code></li>
<li><code>/etc/hostname</code></li>
</ul>
<h2 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h2><p>echo -e 可以输出转义字符例如 <code>echo -e &quot;abc\ndef&quot;&gt; file</code>, 注意有些shell支持的不好，比如sh（会把-e 一同输出出去），bash支持良好，最好的办法还是用printf命令替代echo -e， 注意printf命令不支持浮点类型</p>
<h2 id="pipe"><a href="#pipe" class="headerlink" title="pipe"></a>pipe</h2><p>popen, pclose - pipe stream to or from a process</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function">FILE *<span class="title">popen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *command, <span class="keyword">const</span> <span class="keyword">char</span> *type)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pclose</span><span class="params">(FILE *stream)</span></span>;</div></pre></td></tr></table></figure>
<p>pipe 实际上是fork了一个子进程来运行，所以调用popen运行的命令和主程序share同一套文件描述符</p>
<p>popen 打开的fp不能rewind(), 只有文件可以rewind 而pipe是一个流Stream</p>
<h2 id="xmllint"><a href="#xmllint" class="headerlink" title="xmllint"></a>xmllint</h2><p>xmllint是一个很方便的处理及验证xml的工具，linux下只要安装libxml2就可以使用这个命令，下面整理一些常用功能</p>
<ul>
<li>–format 此参数用于格式化xml，使其具有良好的可读性。</li>
<li>–noblanks 与–format相反，有时为了节省传输量，我们希望去掉xml中的空白，这时我们可以使用–noblanks命令</li>
<li>–schema 使用scheam验证xml文件的正确性 <code>xmllint --schema person.xsd person.xml</code></li>
</ul>
<h2 id="共享库的兼容问题"><a href="#共享库的兼容问题" class="headerlink" title="共享库的兼容问题"></a>共享库的兼容问题</h2><p>动态链接库一般以lib开头，形如libmymodule.so.1.0.0. 后面跟的三个版本号，从左到右的含义为：</p>
<p>1) 大版本号，当接口变得和之前不兼容，则新增一个大版本号。<br>2) 一般增加了接口，不过旧的接口不变，则新增此版本号。<br>3) 接口不做任何变化，只是实现做了修改，则新增此版本号。</p>
<p>可以用ldconfig来设置程序对应的lib版本</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nm policyserver <span class="comment">//查看导出符号</span></div></pre></td></tr></table></figure>
<h2 id="PATH"><a href="#PATH" class="headerlink" title="PATH"></a>PATH</h2><p>每个shell都有自己的PATH，从这个shell运行的程序共享这个shell的PATH, 如果需要永久性保存一个PATH，则需要在/etc/profile或者~/.bashrc_profile中加入<code>export PATH=/xxx/yyy:$PATH</code></p>
<h2 id="openssl生成证书"><a href="#openssl生成证书" class="headerlink" title="openssl生成证书"></a>openssl生成证书</h2><ol>
<li>用户浏览器将其SSL版本号、加密设置参数、与session有关的数据以及其它一些必要信息发送到服务器。</li>
<li>服务器将其SSL版本号、加密设置参数、与session有关的数据以及其它一些必要信息发送给浏览器，同时发给浏览器的还有服务器的证书。如果配置服务器的SSL需要验证用户身份，还要发出请求要求浏览器提供用户证书。</li>
<li>客户端检查服务器证书，如果检查失败，提示不能建立SSL连接。如果成功，那么继续。</li>
<li>客户端浏览器为本次会话生成div-master secret，并将其用服务器公钥加密后发送给服务器。</li>
<li>如果服务器要求鉴别客户身份，客户端还要再对另外一些数据签名后并将其与客户端证书一起发送给服务器。</li>
<li>如果服务器要求鉴别客户身份，则检查签署客户证书的CA是否可信。如果不在信任列表中，结束本次会话。如果检查通过，服务器用自己的私钥解密收到的div-master secret，并用它通过某些算法生成本次会话的master secret。</li>
<li>客户端与服务器均使用此master secret生成本次会话的会话密钥(对称密钥)。在双方SSL握手结束后传递任何消息均使用此会话密钥。这样做的主要原因是对称加密比非对称加密的运算量低一个数量级以上，能够显著提高双方会话时的运算速度。</li>
<li>客户端通知服务器此后发送的消息都使用这个会话密钥进行加密。并通知服务器客户端已经完成本次SSL握手。</li>
<li>服务器通知客户端此后发送的消息都使用这个会话密钥进行加密。并通知客户端服务器已经完成本次SSL握手。</li>
<li>本次握手过程结束，会话已经建立。双方使用同一个会话密钥分别对发送以及接受的信息进行加、解密。</li>
</ol>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//生成CA根证书及私钥</span></div><div class="line">mkdir demoCA &amp;&amp; cd demoCA &amp;&amp; mkdir <span class="keyword">private</span> crl certs newcerts <span class="meta">#新建证书存放目录</span></div><div class="line">echo <span class="string">'00'</span> &gt; serial <span class="meta">#新建serial文件并写入初始序列号00</span></div><div class="line">touch <span class="keyword">index</span>.txt <span class="meta">#新建index.txt空文件</span></div><div class="line">openssl genrsa -out <span class="keyword">private</span>/cakey.pem <span class="number">1024</span> <span class="meta">#生成CA根证书私钥</span></div><div class="line">openssl req -<span class="keyword">new</span> -x509 -key <span class="keyword">private</span>/cakey.pem  -out cacert.pem <span class="meta">#生成CA根证书，注意如果不是-x509生成的是一个证书的request，还要自签名CA： openssl ca -selfsign xxxxxxxxxxx</span></div><div class="line"><span class="comment">//生成服务器证书私钥、证书，可用于https服务器</span></div><div class="line">openssl genrsa -out <span class="keyword">private</span>/<span class="keyword">server</span>.key <span class="number">1024</span></div><div class="line">openssl req -<span class="keyword">new</span> -key <span class="keyword">private</span>/<span class="keyword">server</span>.key -out crl/<span class="keyword">server</span>.csr <span class="meta">#生成证书请求文件，可提供认证CA签核，或自签名。</span></div><div class="line"><span class="comment">//在这之前，你可能需要修改配置`/usr/lib/ssl/openssl.cnf`指定CA的位置, 否则退回上一级执行这个</span></div><div class="line">cd .. &amp;&amp; openssl ca -in ./demoCA/crl/<span class="keyword">server</span>.csr -out ./demoCA/certs/<span class="keyword">server</span>.crt <span class="meta">#自签名证书</span></div><div class="line"></div><div class="line">openssl pkcs12 -export -clcerts -in  certs/<span class="keyword">server</span>.crt -inkey <span class="keyword">private</span>/<span class="keyword">server</span>.key -out <span class="keyword">server</span>.p12</div></pre></td></tr></table></figure>
<p>PKCS#12包含私钥，所以在需要客户端验证的时候要用PKCS证书，而crt不包含私钥</p>
<ul>
<li>证书通常包含三种，CA证书，server证书，client证书</li>
<li>server和client证书（两者实际上可以互换）都是有CA签发的（应包含私钥），如果是crt格式其中是只有他的一个公共证书和公钥，PKCS#12可以包含私钥和公共证书</li>
<li>也可以没有CA证书，server和client自签名自己的证书</li>
<li>x509是一个证书格式，不是一个算法</li>
<li>证书是一个链，包含从根CA到用户cert所有证书，验证的时候要逐一验证。</li>
</ul>
<p>CA的类别</p>
<ul>
<li>自签名 CA: 在自签名 CA 中，证书中的公钥和用于验证证书的密钥是相同的。一些自签名 CA 是根 CA（参见第三项）。</li>
<li>从属 CA: 在从属 CA 中，证书中的公钥和用于核实证书的密钥是不同的。一个 CA 向另一个 CA 颁发证书的过程叫做 交叉认证 。</li>
<li>根 CA: 根 CA 是一种特殊的 CA，它受到客户无条件地信任，位于证书层次结构的最高层。所有证书链均终止于根 CA。根颁发机构必须对它自己的证书签名，因为在证书层次结构中再也没有更高的认证机构了。</li>
<li>所有自签名 CA 都是根 CA，因为到自签名 CA 时证书链就终止了。</li>
</ul>
<h2 id="vino"><a href="#vino" class="headerlink" title="vino"></a>vino</h2><p>No security type 问题解决方法<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gsettings <span class="built_in">set</span> org.gnome.Vino <span class="keyword">require</span><span class="params">-encryption</span> <span class="literal">false</span></div></pre></td></tr></table></figure></p>
<h2 id="UNIX-socket上限"><a href="#UNIX-socket上限" class="headerlink" title="UNIX socket上限"></a>UNIX socket上限</h2><p>在使用Nginx+gunicorn+web.py unix socket方式时候，发现nginx会报<code>“connect() to unix:/dev/shm/fcgi.sock failed (11: Resource temporarily unavailable) while connecting to upstream”</code> 原因是需要修改如下：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cat <span class="regexp">/proc/</span>sys<span class="regexp">/net/</span>core<span class="regexp">/somaxconn /</span>/默认是<span class="number">128</span>，定义了系统中每一个端口最大的监听队列的长度，这是个全局的参数</div><div class="line">echo <span class="number">8192</span> &gt; <span class="regexp">/proc/</span>sys<span class="regexp">/net/</span>core<span class="regexp">/somaxconn /</span><span class="regexp">/放到/</span>etc/rc.local中</div></pre></td></tr></table></figure>
<p><a href="http://www.philsallee.com/mbsteg/index.html" target="_blank" rel="external">Reference of /proc/sys/net/core</a></p>
<h2 id="mv-tip"><a href="#mv-tip" class="headerlink" title="mv tip"></a>mv tip</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">mkdir</span> folder1</div><div class="line"><span class="built_in">mkdir</span> folder2</div><div class="line">touch folder1/file1</div><div class="line">touch folder2/file2</div><div class="line">mv -f folder1 folder2</div></pre></td></tr></table></figure>
<p>这个时候folder1会成为folder2的一个子文件夹，而如果两个都是空文件夹的时候，才会是重命名到folder2</p>
<h2 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h2><p>It’s a process that is dead, but its parent was busy doing some other work, hence it could not collect the child’s exit status. </p>
<h2 id="environment"><a href="#environment" class="headerlink" title="environment"></a>environment</h2><p>系统启动时候加载/etc/environment, 登陆时加载/etc/profile，针对每个用户的加载~/.profile, 对于non-login-shell, 读取~/.bashrc</p>
<h2 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h2><p>使用现有shell运行程序, 而不是作为子进程</p>
<h2 id="sys-proc-tmpfs"><a href="#sys-proc-tmpfs" class="headerlink" title="sys, proc, tmpfs"></a>sys, proc, tmpfs</h2><p>The sysfs filesystem was mentioned briefly above. One may wonder how sysfs knows about the devices present on a system and what device numbers should be used for them. Drivers that have been compiled into the kernel directly register their objects with a sysfs (devtmpfs internally) as they are detected by the kernel. For drivers compiled as modules, this registration will happen when the module is loaded. Once the sysfs filesystem is mounted (on /sys), data which the drivers register with sysfs are available to userspace processes and to udevd for processing (including modifications to device nodes).</p>
<ul>
<li>With the development of the unstable 2.5 kernel tree, later released as the 2.6 series of stable kernels, a new virtual filesystem called sysfs came to be. The job of sysfs is to export a view of the system’s hardware configuration to userspace processes. With this userspace-visible representation, the possibility of developing a userspace replacement for devfs became much more realistic.</li>
</ul>
<h2 id="Driver"><a href="#Driver" class="headerlink" title="Driver"></a>Driver</h2><p>Linux的driver是根据一个设备ID来匹配kernel module的</p>
<h2 id="udev"><a href="#udev" class="headerlink" title="udev"></a>udev</h2><p>通常来说linux不能保证多个同样的设备每次在被创建文件的时候对应同一个文件名，所以我们可以在<code>/etc/udev/rules.d/</code>中创建相关配置</p>
<ul>
<li>Using the Udev method, only those devices which are detected by the kernel get device nodes created for them. Because these device nodes will be created each time the system boots, they will be stored on a devtmpfs file system (a virtual file system that resides entirely in system memory). Device nodes do not require much space, so the memory that is used is negligible</li>
</ul>
<h2 id="交叉编译"><a href="#交叉编译" class="headerlink" title="交叉编译"></a>交叉编译</h2><ul>
<li>–with-sysroot=$LFS  For cross compilation, this tells the build system to look in $LFS for the target system libraries as needed.</li>
<li>–target=$LFS_TGT Because the machine description in the LFS_TGT variable is slightly different than the value returned by the config.guess script, this switch will tell the configure script to adjust Binutil’s build system for building a cross linker</li>
<li>binutil, gcc, glibc 是比较关键的交叉编译部件，需要制定LFS_TGT, 可以用现有平台的编译器编译出对方平台的编译器</li>
</ul>
<p><a href="http://www.cppblog.com/iuranus/archive/2011/07/22/151615.html" target="_blank" rel="external">Reference of target, build, host</a></p>
<h2 id="chroot"><a href="#chroot" class="headerlink" title="chroot"></a>chroot</h2><p>chroot之前要mount tmpfs proc 和 dev到新的root</p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ul>
<li>strip 可以去掉程序中的调试用的符号等</li>
<li>fuser 用来查谁用了哪个文件</li>
<li>vmstat 查看磁盘内存吞吐</li>
<li>free</li>
<li>ifstat</li>
<li>proc可以看到进程运行时的cmd和env</li>
<li>管道中常用 ‘-’ 表示stdout或者stdin</li>
<li><code>cut -d “:” -f 2</code> :分割的第二个</li>
<li><code>cut -c 1-12</code> 1-12个字符</li>
<li><code>strings</code> 文件中打印字符串</li>
<li><code>tar</code> 通常不会使用-P, 这样会把/目录包含进来，在extract的时候-C会不起作用</li>
<li><code>cpio</code> 可以用来备份设备文件，不过要你指定每个文件，他不接受一个文件或者目录参数</li>
<li><code>dd if=xxx of=yyy bs=xbytes count=xxxx</code></li>
<li><code>time</code> 统计运行时间: <code>time [command] [args...]</code></li>
<li><code>tee</code> stdin -&gt; stdout, 也可以同时写入文件，叫双重重定向</li>
<li><code>tr</code> 可以替换或者删除字段</li>
<li><code>^foo^bar</code> 替换上一条命令中的foo为bar然后执行</li>
<li><code>sudo !!</code> 以sudo运行上一条</li>
<li>dpkg-reconfigure 重新配置一个已经安装过的安装包</li>
<li>oh-my-zsh 是个好东西，加上powerline味道更好哦</li>
<li>journalctl 查看systemd log</li>
</ul>
<h2 id="Process-PID-PPID-SID-PGID"><a href="#Process-PID-PPID-SID-PGID" class="headerlink" title="Process PID PPID SID PGID"></a>Process PID PPID SID PGID</h2><p>查看这些可以用<code>ps -ao pid,ppid,sid,pgid,comm</code>, PGID是父进程的PID号，但是父进程的结束并不影响PGID, 组中的所有进程还是沿用同一个PGID，程序中可以对一个进程组来群发信号，SID会有些不同，同一个shell下运行的程序都同属于一个Session，这个Session Leader挂了会导致所有session中的程序退出，所以根据这个我们可以再程序中使用setsid来新建一个新的session，这样程序就不会因为session leader的退出而退出，这也是daemon的基本原理</p>
<h2 id="gsettings"><a href="#gsettings" class="headerlink" title="gsettings"></a>gsettings</h2><p>GSettings configuration tool</p>
<figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="string">gsettings </span><span class="built_in">list-schema</span></div><div class="line"><span class="string">gsettings </span><span class="string">set </span><span class="string">org.</span><span class="string">mate.</span><span class="string">session.</span><span class="string">required-components </span><span class="string">windowmanager </span><span class="string">marco</span></div></pre></td></tr></table></figure>
<h2 id="readlink"><a href="#readlink" class="headerlink" title="readlink"></a>readlink</h2><p>获取符号链接</p>
<figure class="highlight tcl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">readlink /<span class="keyword">proc</span>/$&#123;<span class="keyword">pid</span>&#125;/exe</div></pre></td></tr></table></figure>
<h2 id="su-and-su"><a href="#su-and-su" class="headerlink" title="su and su -"></a><code>su</code> and <code>su -</code></h2><p>进入超级用户模式。也就是输入<code>su -</code>,系统会让你输入超级用户密码，输入密码后就进入了超级用户模式。（当然，你也可以直接用root用）<br>(注意有- ，这和<code>su</code>是不同的，在用命令<code>su</code>的时候只是切换到root，但没有把root的环境变量传过去，还是当前用户的环境变量，用<code>su -</code>命令将环境变量也一起带过去，就象和root登录一样)</p>
<h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><ul>
<li><code>for i in {1..10}; do ./elk_tester.py done</code></li>
</ul>
<h2 id="给重要文件加锁"><a href="#给重要文件加锁" class="headerlink" title="给重要文件加锁"></a>给重要文件加锁</h2><p>只读权限示例：给重要文件加锁（添加不可修改位 <code>immutable</code>)，以避免各种误操作带来的灾难性后果（例如 : <code>rm -rf</code>）</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ </span>chattr +i regular_file</div><div class="line"><span class="variable">$ </span>lsattr regular_file</div><div class="line">----i-------- regular_file</div><div class="line"><span class="variable">$ </span>rm regular_file    <span class="comment">#加immutable位后就无法对文件进行任何“破坏性”的活动啦</span></div><div class="line"><span class="symbol">rm:</span> remove write-protected regular file `regular_file<span class="string">'? y</span></div><div class="line">rm: cannot remove `regular_file': Operation <span class="keyword">not</span> permitted</div><div class="line"><span class="variable">$ </span>chattr -i regular_file <span class="comment">#如果想对它进行常规操作，那么可以把这个位去掉</span></div><div class="line"><span class="variable">$ </span>rm regular_file</div></pre></td></tr></table></figure>
<h2 id="主次设备号"><a href="#主次设备号" class="headerlink" title="主次设备号"></a>主次设备号</h2><p>主 (major)、次(minor)设备号的作用有不同。当一个设备文件被打开时，内核会根据主设备号（major number）去查找在内核中已经以主设备号注册的驱动（可以 <code>cat /proc/devices</code> 查看已经注册的驱动号和主设备号的对应情况），而次设备号（minor number）则是通过内核传递给了驱动本身（参考《The Linux Primer》第十章）。因此，对于内核而言，通过主设备号就可以找到对应的驱动去识别某个设备，而对于驱动而言，为了能够更复杂地访问设备，比如访问设备的不同部分（如硬件通过分区分成不同部分，而出现 hda1，hda2，hda3 等），比如产生不同要求的随机数（如 <code>/dev/random</code> 和 <code>/dev/urandom</code> 等）。</p>
<h2 id="locate省去打绝对路径"><a href="#locate省去打绝对路径" class="headerlink" title="locate省去打绝对路径"></a>locate省去打绝对路径</h2><figure class="highlight clean"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">insmod `locate usbhid.ko`</div></pre></td></tr></table></figure>
<h2 id="GNU-parallel"><a href="#GNU-parallel" class="headerlink" title="GNU parallel"></a>GNU parallel</h2><p>可以并行的处理Pipe</p>
<h2 id="X-windows-Xsession-配置"><a href="#X-windows-Xsession-配置" class="headerlink" title="X windows Xsession 配置"></a>X windows Xsession 配置</h2><p><code>/var/lib/AccountService/users/[username]</code> 里面的xsession指定的，具体支持哪些xsession，查看这个目录<code>/usr/share/xsessions/</code></p>
<h2 id="systemd-and-upstart"><a href="#systemd-and-upstart" class="headerlink" title="systemd and upstart"></a>systemd and upstart</h2><ul>
<li><code>&quot;systemctl status networking.service&quot; and &quot;journalctl -xe&quot;</code> 可以查看服务启动的错误原因</li>
</ul>
<h3 id="upstart"><a href="#upstart" class="headerlink" title="upstart"></a>upstart</h3><p>upstart 没有 inittab， 所有的配置文件都在/etc/init/目录下，这些脚本是不可执行的，包含两种类型conf和override, rc-sysinit.conf是系统初始化的配置</p>
<ul>
<li><code>man 8 init</code></li>
</ul>
<h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><ul>
<li><code>find -maxdepth 1 -type f -exec ls -al {} \;</code> 一个转译的;表示命令的结束，这个命令是针对每一个文件执行一次ls</li>
<li><code>find -maxdepth 1 -type f -exec ls -al {} +</code> 这种情况文件只能加在命令尾部，被查到的文件被append到ls尾部，这个命令只执行一次ls</li>
</ul>
<h2 id="available-memroy"><a href="#available-memroy" class="headerlink" title="available memroy"></a>available memroy</h2><p>Warning signs of a genuine low memory situation that you may want to look into:</p>
<ul>
<li>available memory (or “free + buffers/cache”) is close to zero</li>
<li>swap used increases or fluctuates</li>
<li>dmesg | grep oom-killer shows the OutOfMemory-killer at work</li>
</ul>
<p><a href="https://linux-mm.org/Drop_Caches" target="_blank" rel="external">How to force to release the cache</a></p>
<h2 id="nice"><a href="#nice" class="headerlink" title="nice"></a>nice</h2><p>top命令里有%ni,与此相关，nice命令可以修改进程的优先级，这样就可以让进程运行得不那么频繁。 这个功能在运行cpu密集型的后台进程或批处理作业时尤为有用。 nice值的取值范围是[-20,19],-20表示最高优先级，而19表示最低优先级。 Linux进程的默认nice值为0。使用nice命令（不带任何参数时）可以将进程的nice值设置为10。这样调度器就会将此进程视为较低优先级的进程，从而减少cpu资源的分配。</p>
<h2 id="apropos"><a href="#apropos" class="headerlink" title="apropos"></a>apropos</h2><p>根据关键字找相关的指令</p>
<h2 id="setuid-setgid"><a href="#setuid-setgid" class="headerlink" title="setuid, setgid"></a>setuid, setgid</h2><p>如果一个可执行文件setuid/gid那么他拥有可执行文件owner、group相同的权限, 如果文件是root，那么他具有和root一样的权限很危险</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">chmod u+s <span class="keyword">files</span></div><div class="line">chmod g+s <span class="keyword">files</span></div></pre></td></tr></table></figure>
<h2 id="文件空洞"><a href="#文件空洞" class="headerlink" title="文件空洞"></a>文件空洞</h2><p>在UNIX文件操作中，文件位移量可以大于文件的当前长度，在这种情况下，对该文件的下一次写将延长该文件，并在文件中构成一个空洞，这一点是允许的。位于文件中但没有写过的字节都被设为 0。<br>如果 offset 比文件的当前长度更大，下一个写操作就会把文件“撑大（extend）”。这就是所谓的在文件里创造“空洞（hole）”。没有被实际写入文件的所有字节由重复的 0 表示。空洞是否占用硬盘空间是由文件系统（file system）决定的。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://gaoshen.site/html+css/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Matthew Gao">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Matthew Note">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Matthew Note" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/html+css/" itemprop="url">
                  HTML CSS Notes
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/html+css/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="html+css/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          
              <div class="post-description">
                  一些前端的东西
              </div>
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><ul>
<li>这是一个很让人困惑的CSS特征，我之前也谈到过它。我们大家都知道，当按百分比设定一个元素的宽度时，它是相对于父容器的宽度计算的，但是，对于一些表示竖向距离的属性，例如<code>padding-top</code>,<code>padding-bottom</code>,<code>margin-top</code>,<code>margin-bottom</code>等，当按百分比设定它们时，依据的也是父容器的宽度，而不是高度。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Matthew Gao" />
          <p class="site-author-name" itemprop="name">Matthew Gao</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">40</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">23</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">48</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/matthewgao" target="_blank" title="Github">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  Github
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/xxiaogao" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  Twitter
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/334332999" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  Weibo
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/gaoshen" target="_blank" title="Zhihu">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  Zhihu
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2012 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Matthew Gao</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="http://cdn.bootcss.com/jquery/2.1.3/jquery.min.js"></script>

  
  <script type="text/javascript" src="http://cdn.bootcss.com/fastclick/1.0.5/fastclick.min.js"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"matthewgao"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  








  
  

  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  


</body>
</html>
